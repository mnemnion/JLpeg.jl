<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Patterns and Combination · JLpeg</title><meta name="title" content="Patterns and Combination · JLpeg"/><meta property="og:title" content="Patterns and Combination · JLpeg"/><meta property="twitter:title" content="Patterns and Combination · JLpeg"/><meta name="description" content="Documentation for JLpeg."/><meta property="og:description" content="Documentation for JLpeg."/><meta property="twitter:description" content="Documentation for JLpeg."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JLpeg logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JLpeg</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Patterns and Combination</a><ul class="internal"><li><a class="tocitem" href="#Combination"><span>Combination</span></a></li><li><a class="tocitem" href="#Matching"><span>Matching</span></a></li><li><a class="tocitem" href="#Rules-and-Grammars"><span>Rules and Grammars</span></a></li><li><a class="tocitem" href="#@constgrammar-and-@construle"><span>@constgrammar and @construle</span></a></li></ul></li><li><a class="tocitem" href="../captures/">Captures and Actions</a></li><li><a class="tocitem" href="../pegmatch/">Working with Matched Data</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Patterns and Combination</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Patterns and Combination</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mnemnion/JLpeg.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mnemnion/JLpeg.jl/blob/trunk/docs/src/guide/patterns.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Patterns"><a class="docs-heading-anchor" href="#Patterns">Patterns</a><a id="Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns" title="Permalink"></a></h1><p>Parsing Expression Grammars are built out of patterns. These begin with atomic units of recognition, and are combined into complex rules, which can call other rules, recursively, thereby recognizing context free, and some context sensitive, languages. LPeg, JLpeg&#39;s inspiration, uses a <a href="https://en.wikipedia.org/wiki/SNOBOL">SNOBOL</a>-style set of operator overloads as the basic tool for building up patterns, a practice we also follow.</p><p>Patterns and their combination are the building block of JLpeg recognition engines. They are immutable and may be freely recombined and reused, unlike either regular expressions or the parsers generated by typical compiler-compilers.</p><p>The API of JLpeg hews closely to <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>, with several extensions, refinements, and a more natively Julian character.</p><h2 id="Combination"><a class="docs-heading-anchor" href="#Combination">Combination</a><a id="Combination-1"></a><a class="docs-heading-anchor-permalink" href="#Combination" title="Permalink"></a></h2><p>The basic operations are as follows:</p><table><tr><th style="text-align: right">Operator</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>P(string::String)</code></td><td style="text-align: left">match a literal String <code>string</code></td></tr><tr><td style="text-align: right"><code>P(n::UInt)</code></td><td style="text-align: left">match any <code>n</code> characters</td></tr><tr><td style="text-align: right"><code>P(-n)</code></td><td style="text-align: left">match if there are at least <code>n</code> characters remaining</td></tr><tr><td style="text-align: right"><code>P(sym::Symbol)</code></td><td style="text-align: left">match the rule named <code>:sym</code></td></tr><tr><td style="text-align: right"><code>S(s::String)</code></td><td style="text-align: left">match the <code>S</code>et of all characters in <code>string</code></td></tr><tr><td style="text-align: right"><code>R(&quot;xy&quot;)</code>, <code>R(&#39;x&#39;,&#39;y&#39;)</code></td><td style="text-align: left">matches any character between <code>x</code> and <code>y</code> (<code>R</code>ange)</td></tr><tr><td style="text-align: right"><code>B(patt)</code></td><td style="text-align: left">match <code>patt</code> behind the cursor, without advancing</td></tr><tr><td style="text-align: right"><code>U8(byte::UInt8)</code></td><td style="text-align: left">match one byte of the string, invalid UTF-8 or not</td></tr><tr><td style="text-align: right"><code>patt^n</code></td><td style="text-align: left">match at least <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^-n</code></td><td style="text-align: left">match at most <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^[n:m]</code></td><td style="text-align: left">match between <code>n</code> and <code>m</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^[n]</code></td><td style="text-align: left">match exactly <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt1 * patt2</code></td><td style="text-align: left">match the sequence <code>patt1</code> , <code>patt2</code></td></tr><tr><td style="text-align: right"><code>patt1 | patt2</code></td><td style="text-align: left">match <code>patt1</code> or <code>patt2</code>, in that order</td></tr><tr><td style="text-align: right"><code>patt1 - patt2</code></td><td style="text-align: left">match <code>patt1</code> if <code>patt2</code> does not match</td></tr><tr><td style="text-align: right"><code>!patt</code>, <code>¬patt</code></td><td style="text-align: left">negative lookahead, succeeds if <code>patt</code> fails</td></tr><tr><td style="text-align: right"><code>~patt</code></td><td style="text-align: left">lookahead, match <code>patt</code> without advancing</td></tr><tr><td style="text-align: right"><code>patt1 &gt;&gt; patt2</code></td><td style="text-align: left">match <code>patt1</code>, then search the string for the next <code>patt2</code>.</td></tr><tr><td style="text-align: right"><code>P(true)</code>, <code>ε</code></td><td style="text-align: left">always succeed</td></tr><tr><td style="text-align: right"><code>P(false)</code>, <code>∅</code></td><td style="text-align: left">always fail</td></tr></table><p>In keeping with the spirit of LPeg, <code>P&quot;string&quot;</code> is equivalent to <code>P(&quot;string&quot;)</code>, and this is true for <code>S</code> and <code>R</code> as well.  These basic operations are not recursive, and without further modification will match to the longest substring recognized by the pattern.  This is sufficient to match all regular languages.  Note that ordered choice in PEGs is traditionally spelled &quot;/&quot;, but this has the wrong precedence for us.  Just remember that it has different semantics from the &quot;|&quot; in context-free grammars.</p><h3 id="A-Note-About-Piracy"><a class="docs-heading-anchor" href="#A-Note-About-Piracy">A Note About Piracy</a><a id="A-Note-About-Piracy-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-About-Piracy" title="Permalink"></a></h3><p>You will note that combining Patterns involves a great deal of operator overloading. In Julian circles, operators are presumed to have <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">a certain contract</a>, although this is informal and has a certain latitude.  Some of our operators comply with this expectation: <code>*</code> and <code>^</code> are used for concatenation and repetition for <code>AbstractString</code>s, as they are with <code>Pattern</code>s, although the meaning of repetition is broader for patterns.  Others do not: particularly egregious is <code>!</code>, which is expected to always return a <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool"><code>Bool</code></a>.  <code>|</code> and <code>-</code> are justifiable, in my opinion: <code>|</code> is firmly grounded in tradition and <code>a | b</code> would be pronounced &quot;a or b&quot;, while subtraction has a huge variety of meanings in mathematics; our use, as one should expect, is neither commutative nor associative. <code>~</code> and <code>&gt;&gt;</code> bear little resemblance to their ordinary meanings.</p><p>Broadly speaking, the combinator operators in JLpeg are a combination of availability, operator precedence, and mnemnonic weight, in that order.  For example, <code>&amp;patt</code> is the signifier for lookahead in the PEG definition, we use <code>~</code> because it&#39;s unary, and Julia has but few unary operators.</p><p>In any case, we shadow operators, rather than overloading the ones found in <code>Base</code>, and they aren&#39;t exported.  We provide <a href="../../reference/#JLpeg.Combinators"><code>JLpeg.Combinators</code></a> as an easy way to bring them into scope if desired.  Most users will stick to the <a href="../../reference/#JLpeg.GrammarMacros.@rule"><code>@rule</code></a> and <a href="../../reference/#JLpeg.GrammarMacros.@grammar"><code>@grammar</code></a> macros, which don&#39;t require bringing operators into scope.</p><h2 id="Matching"><a class="docs-heading-anchor" href="#Matching">Matching</a><a id="Matching-1"></a><a class="docs-heading-anchor-permalink" href="#Matching" title="Permalink"></a></h2><p><a href="../../reference/#Base.match"><code>match</code></a><code>(pattern::</code><a href="../../reference/#JLpeg.Pattern"><code>Pattern</code></a>, <code>string</code>::<a href="https://docs.julialang.org/en/v1/base/strings/#Core.AbstractString">AbstractString</a>) will attempt to match the pattern against the string, returning a <a href="../../reference/#JLpeg.PegMatch"><code>PegMatch</code></a> <code>&lt;:</code> <a href="https://docs.julialang.org/en/v1/base/strings/#Base.RegexMatch">AbstractMatch</a>. In the event of a failure, it returns a <a href="../../reference/#JLpeg.PegFail"><code>PegFail</code></a>, with the index of the failure at <code>.errpos</code>.  Note that unlike regular expressions, JLpeg will not skip ahead to find a pattern in a string, unless the pattern is so constructed.  We offer the shorthand <code>&quot;&quot; &gt;&gt; patt</code>, the &quot;fast-forward&quot; operator, to convert a pattern into its searching equivalent.  <code>P&quot;&quot;</code> matches the empty string, and JLPeg will convert Strings and Integers (but not Bools) into patterns when able.</p><pre><code class="language-julia-repl hljs">julia&gt; match(P&quot;123&quot;, &quot;123456&quot;)
PegMatch([&quot;123&quot;])

julia&gt; match(P&quot;abc&quot; * &quot;123&quot;, &quot;abc123&quot;)
PegMatch([&quot;abc123&quot;])

julia&gt; match(P&quot;abc&quot; | &quot;123&quot;, &quot;123&quot;)
PegMatch([&quot;123&quot;])

julia&gt; match(P&quot;abc&quot;^1, &quot;abcabcabc&quot;)
PegMatch([&quot;abcabcabc&quot;])

julia&gt; match((!S&quot;123&quot; * R&quot;09&quot;)^1, &quot;0987654321&quot;)
PegMatch([&quot;0987654&quot;])

julia&gt; match(&quot;&quot; &gt;&gt; P&quot;5&quot;, &quot;0987654321&quot;)
PegMatch([&quot;098765&quot;])

julia&gt; match(~P&quot;abc&quot;, &quot;abc123&quot;)
PegMatch([&quot;&quot;])

julia&gt; match(~P&quot;abc&quot;, &quot;123abc&quot;) # fails
PegFail(&quot;123abc&quot;, 1)</code></pre><p>The operators introduce a pattern &#39;context&#39;, where any <code>a &lt;op&gt; b</code> combination where <code>a</code> or <code>b</code> is a Pattern will attempt to cast the other argument to a Pattern when appropriate.  Generally, a <code>MethodError</code> may be repaired by using <code>P</code> on the left side of the the operator, although we can&#39;t guarantee that other method overloads for those operators might apply.  Notably, <code>*</code> is used for concatenation of strings, although in the JLpeg context, <code>P&quot;abc&quot; * P&quot;123&quot;</code> is in fact the same as <code>P(&quot;abc&quot; * &quot;123&quot;)</code>.</p><p>This UI is adequate for light work, but the <a href="#Rules-and-Grammars">macros</a> discussed later are cleaner to work with, defined such that <code>P</code> should never be necessary, although any of the public names in the <a href="../../reference/"><code>JLpeg</code></a> module may be used, and needn&#39;t be imported into your package to do so.</p><p>Note that, unlike regular expressions, PEG matching always starts with the first character.  Any match returned by a call to <code>match(patt, string)</code> will therefore be a prefix of the string, up to and including the entire string.</p><p>Most interesting uses of pattern recognition will call for more than matching the longest substring.  For those more complex cases, we have <a href="#Captures"><code>Captures</code></a> and <a href="#Actions"><code>Actions</code></a>.</p><h2 id="Rules-and-Grammars"><a class="docs-heading-anchor" href="#Rules-and-Grammars">Rules and Grammars</a><a id="Rules-and-Grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Rules-and-Grammars" title="Permalink"></a></h2><p>While simple patterns may be composed by assigning to variables and using those variable names to build up more complex patterns, this doesn&#39;t allow for recursion, which is essential for matching many strings of interest, perhaps most.</p><p>For this purpose, we have rules, which are simply patterns with a name.  A rule with no references to another rule within it may be used for matching directly, while those with such references (including a reference to itself) must be composed into grammars.</p><p>As is the PEG convention, a rule reduction uses the left arrow <code>←</code>, which you can type as <code>\leftarrow</code> (or in fact <code>\lefta[TAB]</code>), also defined as <code>&lt;--</code>.  A simple grammar can look like this:</p><pre><code class="language-julia hljs">abc_and = :a &lt;-- P&quot;abc&quot; * (:b | P&quot;&quot;)
_123s   = :b ← P&quot;123&quot;^1 * :a
abc123  = Grammar(abc_and, _123s)

match(abc123, &quot;abc123123123abc123abc&quot;)</code></pre><p>Although we suggest as a matter of style that a grammar use one arrow form or the other, with <code>←</code> preferred.</p><p>The first rule is the start rule, which must succeed if the match is to succeed.  A grammar which is missing rules will throw a <a href="../../reference/#JLpeg.PegError"><code>PegError</code></a>, but duplicate rules are undefined behavior.  Currently JLpeg will compile the last rule of that name it encounters, but this behavior must not be relied upon.</p><p>The preferred way to create rules and grammars is with the macros <a href="../../reference/#JLpeg.GrammarMacros.@rule"><code>@rule</code></a> and <a href="../../reference/#JLpeg.GrammarMacros.@grammar"><code>@grammar</code></a>, which avoid the tedium of decorating expressions with <a href="../../reference/#JLpeg.P"><code>P</code></a> entirely.  Any <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Integer"><code>Integer</code></a>, <a href="https://docs.julialang.org/en/v1/manual/strings/"><code>String</code></a>, <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Symbols"><code>Symbol</code></a>, or <a href="https://docs.julialang.org/en/v1/manual/strings/#man-characters"><code>Char</code></a>, found on its own, is converted into the pattern equivalent.  While this is not true of booleans, an idiomatic way to spell <code>true</code> and <code>false</code> in JLpeg is <code>&quot;&quot;</code> and <code>S&quot;&quot;</code> respectively (read: &quot;the empty string&quot; and &quot;the empty set&quot;).  These are compiled into the same code as <code>P(true)</code> and <code>P(false)</code>.  JLpeg also defines, but does not export, <code>ε</code> for <code>P(true)</code> and <code>∅</code> for <code>P(false)</code>, and these may be used in grammars and rules as well, with <code>\varepsilon</code> (<code>\vare[TAB]</code>) and <code>\emptyset</code> (<code>\emp[TAB]</code>) respectively.</p><p>Public variable names from <code>JLpeg</code> will always refer to the values they have in the module.  Any other variable will be escaped, so it will have the expected meaning in context.</p><p>To give an example, this rule:</p><pre><code class="language-julia hljs">@rule :a ← &quot;foo&quot; *  [S&quot;123&quot; | &quot;abc&quot;^1]^1</code></pre><p>Is equivalent to this expression:</p><pre><code class="language-julia hljs">a = :a ← P(&quot;foo&quot;) * Cg(S(&quot;123&quot;) | P(&quot;abc&quot;)^1)^1</code></pre><p>Although the definitions of the operators and string macros would allow this reduction:</p><pre><code class="language-julia hljs">a = :a ← P&quot;foo&quot; * Cg(S&quot;123&quot; | P&quot;abc&quot;^1)^1</code></pre><p>Which is a bit less cumbersome (we try).  Note that the <code>@rule</code> form doesn&#39;t require the importation of <code>@S_str</code>, or any other exported name, thanks to the nature of Julia macros.  You may always use any form of a pattern in <code>@rule</code> or <code>@grammar</code>, all of these are equivalent: <code>P(&quot;string&quot;)</code>, <code>P&quot;string&quot;</code>, and <code>&quot;string&quot;</code>.</p><h3 id="A-Sample-Grammar"><a class="docs-heading-anchor" href="#A-Sample-Grammar">A Sample Grammar</a><a id="A-Sample-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#A-Sample-Grammar" title="Permalink"></a></h3><p>A classic example of a task forever beyond the reach of regular expressions is balancing parentheses, with JLpeg this is easy:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar parens begin
           :par ← :s * !1
           :s ← (:b | (!S&quot;()&quot; * 1))^1
           :b ← &#39;(&#39; * :s * &#39;)&#39;
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;(these (must) balance)&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;these (must) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;these (must) balance<span class="sgr31">)</span>&quot;, 22)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must) balanc<span class="sgr31">e</span>&quot;, 22)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance))&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must) balance)<span class="sgr31">)</span>&quot;, 24)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must))) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must))<span class="sgr31">)</span> balance)&quot;, 16)</code></pre><p><code>!1</code> is our equivalent of <code>$</code> in regex, a pattern which only succeeds at the end of input. <code>1</code> will match a single Unicode codepoint, and <code>!</code> is negative lookahead.  The line-oriented equivalent of <code>$</code> is <code>~&quot;\n&quot;</code>.</p><p>The <code>@grammar</code> macro doesn&#39;t define variable names for the rules, only the grammar name given before the expression block.  The first rule is always the start rule.  As the example shows, it doesn&#39;t necessarily match the variable name, although of course it may.</p><h2 id="@constgrammar-and-@construle"><a class="docs-heading-anchor" href="#@constgrammar-and-@construle">@constgrammar and @construle</a><a id="@constgrammar-and-@construle-1"></a><a class="docs-heading-anchor-permalink" href="#@constgrammar-and-@construle" title="Permalink"></a></h2><p>It&#39;s better style, and good for performance, to define global variables as <a href="https://docs.julialang.org/en/v1/base/base/#const"><code>const</code></a>.  Julia&#39;s macro system currently <a href="https://github.com/JuliaLang/julia/issues/34168">doesn&#39;t offer</a> a way to determine what scope a macro is executing in, so for use in the global scope, JLpeg has the macros <a href="../../reference/#JLpeg.GrammarMacros.@constgrammar"><code>@constgrammar</code></a> and <a href="../../reference/#JLpeg.GrammarMacros.@construle"><code>@construle</code></a>, which differ from their cousins only in declaring the variable to be constant.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../captures/">Captures and Actions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 18 February 2024 19:56">Sunday 18 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
