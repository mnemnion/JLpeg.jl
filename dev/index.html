<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JLpeg Guide · JLpeg</title><meta name="title" content="JLpeg Guide · JLpeg"/><meta property="og:title" content="JLpeg Guide · JLpeg"/><meta property="twitter:title" content="JLpeg Guide · JLpeg"/><meta name="description" content="Documentation for JLpeg."/><meta property="og:description" content="Documentation for JLpeg."/><meta property="twitter:description" content="Documentation for JLpeg."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="JLpeg logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>JLpeg</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>JLpeg Guide</a><ul class="internal"><li><a class="tocitem" href="#Patterns"><span>Patterns</span></a></li><li><a class="tocitem" href="#Combination"><span>Combination</span></a></li><li><a class="tocitem" href="#Matching"><span>Matching</span></a></li><li><a class="tocitem" href="#Captures"><span>Captures</span></a></li><li><a class="tocitem" href="#Actions"><span>Actions</span></a></li><li><a class="tocitem" href="#Working-With-Matched-Data"><span>Working With Matched Data</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JLpeg Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JLpeg Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mnemnion/JLpeg.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mnemnion/JLpeg.jl/blob/trunk/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="JLpeg:-Pattern-Matching-and-Parsing-For-Julia"><a class="docs-heading-anchor" href="#JLpeg:-Pattern-Matching-and-Parsing-For-Julia">JLpeg: Pattern Matching and Parsing For Julia</a><a id="JLpeg:-Pattern-Matching-and-Parsing-For-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#JLpeg:-Pattern-Matching-and-Parsing-For-Julia" title="Permalink"></a></h1><p>JLpeg provides a fast <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammar</a> engine for matching patterns in strings, using a bytecode virtual machine based on the pioneering work of <a href="https://www.inf.puc-rio.br/~roberto/docs/peg.pdf">Roberto Ierusalimschy</a>.</p><p>Compared to regular expressions, PEGs offer greater power and expressivity.  They match a superset of regex patterns, while formalizing and extending the deviations from regular languages offered by production regex engines such as PCRE.  PEGs are able to parse recursive rule patterns, employ lookahead and lookbehind predicates, and freely intermix functions for context-sensitive matching.  JLpeg has an innovative mechanism for matching against two regions of a string, which can match opening and closing XML tags, and cleanly parse indentation-sensitive languages.</p><p>Compared with parser combinators, a more common algorithm for matching PEG grammars, the approach taken by this package is superior.  A bytecode interpreter allows several key optimizations which parser combinators do not in practice employ. Generally such libraries choose between a naive backtracking algorithm with bad time complexity, and a memorizing packrat algorithm which trades this for bad space complexity, with consequent memory pressure.  Critically, a <code>JLpeg</code> pattern of the form <code>a ← &quot;b&quot; / . a</code> becomes a loop, rather than consuming the program stack.  JLpeg generates programs which may be inspected and modified, and uses an innovative thrown-label pattern to allow excellent error reporting and recovery.</p><p>Compared with a &quot;compiler compiler&quot; such as ANTLR or the classic yacc/bison, <code>JLpeg</code> does not generate source code, but rather bytecode, which Julia is able to JIT into near-optimal machine code on the fly.  These systems require an imput stream to be reduced to tokens, an abstraction PEGs do not need, which allows <code>JLpeg</code> to parse contextually-valid grammars which cannot be readily tokenized.  PEGs are also far more suitable for scanning, captures, and other pattern-recognition tasks than these programs, which are only well-suited to parsing of full grammars, a task <code>JLpeg</code> also excels at.</p><div class="admonition is-warning"><header class="admonition-header">UTF-8 Native</header><div class="admonition-body"><p>JLpeg is a parser for <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, <strong>only</strong>. This is the native encoding for Julia, and the only one anyone should be using, in the author&#39;s opinion.  Text in other encodings must be converted, or JLpeg patterns will simply fail.  The interface accepts AbstractStrings, which includes those in other encodings, and no attempt is made to detect this particular failure mode.  JLpeg will parse invalid UTF-8 sequences without throwing errors, and even provides the raw patterns needed to match them, but provides no way to convert patterns to work with any other encoding.  If you have strings in another format, you can use <a href="https://docs.julialang.org/en/v1/base/strings/#Base.transcode"><code>transcode</code></a> from the Julia standard library to convert them to be compatible with the rest of Julia, and JLpeg.</p></div></div><h2 id="Patterns"><a class="docs-heading-anchor" href="#Patterns">Patterns</a><a id="Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns" title="Permalink"></a></h2><p>Parsing Expression Grammars are built out of patterns. These begin with atomic units of recognition, and are combined into complex rules, which can call other rules, recursively, thereby recognizing context free, and some context sensitive, languages. LPeg, JLpeg&#39;s inspiration, uses a <a href="https://en.wikipedia.org/wiki/SNOBOL">SNOBOL</a>-style set of operator overloads as the basic tool for building up patterns, a practice we also follow.</p><p>Patterns and their combination are the building block of JLpeg recognition engines. They are immutable and may be freely recombined and reused, unlike either regular expressions or the parsers generated by typical compiler-compilers.</p><p>The API of JLpeg hews closely to <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>, with several extensions, refinements, and a more natively Julian character.</p><h2 id="Combination"><a class="docs-heading-anchor" href="#Combination">Combination</a><a id="Combination-1"></a><a class="docs-heading-anchor-permalink" href="#Combination" title="Permalink"></a></h2><p>The basic operations are as follows:</p><table><tr><th style="text-align: right">Operator</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>P(string::String)</code></td><td style="text-align: left">match a literal String <code>string</code></td></tr><tr><td style="text-align: right"><code>P(n::UInt)</code></td><td style="text-align: left">match any <code>n</code> characters</td></tr><tr><td style="text-align: right"><code>P(-n)</code></td><td style="text-align: left">match if there are at least <code>n</code> characters remaining</td></tr><tr><td style="text-align: right"><code>P(sym::Symbol)</code></td><td style="text-align: left">match the rule named <code>:sym</code></td></tr><tr><td style="text-align: right"><code>S(s::String)</code></td><td style="text-align: left">match the <code>S</code>et of all characters in <code>string</code></td></tr><tr><td style="text-align: right"><code>R(&quot;xy&quot;)</code>, <code>R(&#39;x&#39;,&#39;y&#39;)</code></td><td style="text-align: left">matches any character between <code>x</code> and <code>y</code> (<code>R</code>ange)</td></tr><tr><td style="text-align: right"><code>B(patt)</code></td><td style="text-align: left">match <code>patt</code> behind the cursor, without advancing</td></tr><tr><td style="text-align: right"><code>patt^n</code></td><td style="text-align: left">match at least <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^-n</code></td><td style="text-align: left">match at most <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^[n:m]</code></td><td style="text-align: left">match between <code>n</code> and <code>m</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt^[n]</code></td><td style="text-align: left">match exactly <code>n</code> repetitions of <code>patt</code></td></tr><tr><td style="text-align: right"><code>patt1 * patt2</code></td><td style="text-align: left">match the sequence <code>patt1</code> , <code>patt2</code></td></tr><tr><td style="text-align: right"><code>patt1 | patt2</code></td><td style="text-align: left">match <code>patt1</code> or <code>patt2</code>, in that order</td></tr><tr><td style="text-align: right"><code>patt1 - patt2</code></td><td style="text-align: left">match <code>patt1</code> if <code>patt2</code> does not match</td></tr><tr><td style="text-align: right"><code>!patt</code>, <code>¬patt</code></td><td style="text-align: left">negative lookahead, succeeds if <code>patt</code> fails</td></tr><tr><td style="text-align: right"><code>~patt</code></td><td style="text-align: left">lookahead, match <code>patt</code> without advancing</td></tr><tr><td style="text-align: right"><code>patt1 &gt;&gt; patt2</code></td><td style="text-align: left">match <code>patt1</code>, then search the string for the next <code>patt2</code>.</td></tr><tr><td style="text-align: right"><code>P(true)</code>, <code>ε</code></td><td style="text-align: left">always succeed</td></tr><tr><td style="text-align: right"><code>P(false)</code>, <code>∅</code></td><td style="text-align: left">always fail</td></tr></table><p>In keeping with the spirit of LPeg, <code>P&quot;string&quot;</code> is equivalent to <code>P(&quot;string&quot;)</code>, and this is true for <code>S</code> and <code>R</code> as well.  These basic operations are not recursive, and without further modification will match to the longest substring recognized by the pattern.  This is sufficient to match all regular languages.  Note that ordered choice in PEGs is traditionally spelled &quot;/&quot;, but this has the wrong precedence for us.  Just remember that it has different semantics from the &quot;|&quot; in context-free grammars.</p><h3 id="A-Note-About-Piracy"><a class="docs-heading-anchor" href="#A-Note-About-Piracy">A Note About Piracy</a><a id="A-Note-About-Piracy-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-About-Piracy" title="Permalink"></a></h3><p>You will note that combining Patterns involves a great deal of operator overloading. In Julian circles, operators are presumed to have <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">a certain contract</a>, although this is informal and has a certain latitude.  Some of our operators comply with this expectation: <code>*</code> and <code>^</code> are used for concatenation and repetition for <code>AbstractString</code>s, as they are with <code>Pattern</code>s, although the meaning of repetition is broader for patterns.  Others do not: particularly egregious is <code>!</code>, which is expected to always return a <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool"><code>Bool</code></a>.  <code>|</code> and <code>-</code> are justifiable, in my opinion: <code>|</code> is firmly grounded in tradition and <code>a | b</code> would be pronounced &quot;a or b&quot;, while subtraction has a huge variety of meanings in mathematics; our use, as one should expect, is neither commutative nor associative. <code>~</code> and <code>&gt;&gt;</code> bear little resemblance to their ordinary meanings.</p><p>Broadly speaking, the combinator operators in JLpeg are a combination of availability, operator precedence, and mnemnonic weight, in that order.  For example, <code>&amp;patt</code> is the signifier for lookahead in the PEG definition, we use <code>~</code> because it&#39;s unary, and Julia has but few unary operators.</p><p>In any case, we shadow operators, rather than overloading the ones found in <code>Base</code>, and they aren&#39;t exported.  We provide <a href="reference/#JLpeg.Combinators"><code>JLpeg.Combinators</code></a> as an easy way to bring them into scope if desired.  Most users will stick to the <a href="reference/#JLpeg.GrammarMacros.@rule"><code>@rule</code></a> and <a href="reference/#JLpeg.GrammarMacros.@grammar"><code>@grammar</code></a> macros, which don&#39;t require bringing operators into scope.</p><h2 id="Matching"><a class="docs-heading-anchor" href="#Matching">Matching</a><a id="Matching-1"></a><a class="docs-heading-anchor-permalink" href="#Matching" title="Permalink"></a></h2><p><a href="reference/#Base.match"><code>match</code></a><code>(pattern::</code><a href="reference/#JLpeg.Pattern"><code>Pattern</code></a>, <code>string</code>::<a href="https://docs.julialang.org/en/v1/base/strings/#Core.AbstractString">AbstractString</a>) will attempt to match the pattern against the string, returning a <a href="reference/#JLpeg.PegMatch"><code>PegMatch</code></a> <code>&lt;:</code> <a href="https://docs.julialang.org/en/v1/base/strings/#Base.RegexMatch">AbstractMatch</a>. In the event of a failure, it returns a <a href="reference/#JLpeg.PegFail"><code>PegFail</code></a>, with the index of the failure at <code>.errpos</code>.  Note that unlike regular expressions, JLpeg will not skip ahead to find a pattern in a string, unless the pattern is so constructed.  We offer the shorthand <code>&quot;&quot; &gt;&gt; patt</code>, the &quot;fast-forward&quot; operator, to convert a pattern into its searching equivalent.  <code>P&quot;&quot;</code> matches the empty string, and JLPeg will convert Strings and Integers (but not Bools) into patterns when able.</p><pre><code class="language-julia-repl hljs">julia&gt; match(P&quot;123&quot;, &quot;123456&quot;)
PegMatch([&quot;123&quot;])

julia&gt; match(P&quot;abc&quot; * &quot;123&quot;, &quot;abc123&quot;)
PegMatch([&quot;abc123&quot;])

julia&gt; match(P&quot;abc&quot; | &quot;123&quot;, &quot;123&quot;)
PegMatch([&quot;123&quot;])

julia&gt; match(P&quot;abc&quot;^1, &quot;abcabcabc&quot;)
PegMatch([&quot;abcabcabc&quot;])

julia&gt; match((!S&quot;123&quot; * R&quot;09&quot;)^1, &quot;0987654321&quot;)
PegMatch([&quot;0987654&quot;])

julia&gt; match(&quot;&quot; &gt;&gt; P&quot;5&quot;, &quot;0987654321&quot;)
PegMatch([&quot;098765&quot;])

julia&gt; match(~P&quot;abc&quot;, &quot;abc123&quot;)
PegMatch([&quot;&quot;])

julia&gt; match(~P&quot;abc&quot;, &quot;123abc&quot;) # fails
PegFail(&quot;123abc&quot;, 1)</code></pre><p>The operators introduce a pattern &#39;context&#39;, where any <code>a &lt;op&gt; b</code> combination where <code>a</code> or <code>b</code> is a Pattern will attempt to cast the other argument to a Pattern when appropriate.  Generally, a <code>MethodError</code> may be repaired by using <code>P</code> on the left side of the the operator, although we can&#39;t guarantee that other method overloads for those operators might apply.  Notably, <code>*</code> is used for concatenation of strings, although in the JLpeg context, <code>P&quot;abc&quot; * P&quot;123&quot;</code> is in fact the same as <code>P(&quot;abc&quot; * &quot;123&quot;)</code>.</p><p>This UI is adequate for light work, but the <a href="#Rules-and-Grammars">macros</a> discussed later are cleaner to work with, defined such that <code>P</code> should never be necessary, although any of the public names in the <a href="reference/"><code>JLpeg</code></a> module may be used, and needn&#39;t be imported into your package to do so.</p><p>Note that, unlike regular expressions, PEG matching always starts with the first character.  Any match returned by a call to <code>match(patt, string)</code> will therefore be a prefix of the string, up to and including the entire string.</p><p>Most interesting uses of pattern recognition will call for more than matching the longest substring.  For those more complex cases, we have <a href="#Captures"><code>Captures</code></a> and <a href="#Actions"><code>Actions</code></a>.</p><h3 id="Rules-and-Grammars"><a class="docs-heading-anchor" href="#Rules-and-Grammars">Rules and Grammars</a><a id="Rules-and-Grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Rules-and-Grammars" title="Permalink"></a></h3><p>While simple patterns may be composed by assigning to variables and using those variable names to build up more complex patterns, this doesn&#39;t allow for recursion, which is essential for matching many strings of interest, perhaps most.</p><p>For this purpose, we have rules, which are simply patterns with a name.  A rule with no references to another rule within it may be used for matching directly, while those with such references (including a reference to itself) must be composed into grammars.</p><p>As is the PEG convention, a rule reduction uses the left arrow <code>←</code>, which you can type as <code>\leftarrow</code> (or in fact <code>\lefta[TAB]</code>), also defined as <code>&lt;--</code>.  A simple grammar can look like this:</p><pre><code class="language-julia hljs">abc_and = :a &lt;-- P&quot;abc&quot; * (:b | P&quot;&quot;)
_123s   = :b ← P&quot;123&quot;^1 * :a
abc123  = Grammar(abc_and, _123s)

match(abc123, &quot;abc123123123abc123abc&quot;)</code></pre><p>Although we suggest as a matter of style that a grammar use one arrow form or the other, with <code>←</code> preferred.</p><p>The first rule is the start rule, which must succeed if the match is to succeed.  A grammar which is missing rules will throw a <a href="reference/#JLpeg.PegError"><code>PegError</code></a>, but duplicate rules are undefined behavior.  Currently JLpeg will compile the last rule of that name it encounters, but this behavior must not be relied upon.</p><p>The preferred way to create rules and grammars is with the macros <a href="reference/#JLpeg.GrammarMacros.@rule"><code>@rule</code></a> and <a href="reference/#JLpeg.GrammarMacros.@grammar"><code>@grammar</code></a>, which avoid the tedium of decorating expressions with <a href="reference/#JLpeg.P"><code>P</code></a> entirely.  Any <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Integer"><code>Integer</code></a>, <a href="https://docs.julialang.org/en/v1/manual/strings/"><code>String</code></a>, <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Symbols"><code>Symbol</code></a>, or <a href="https://docs.julialang.org/en/v1/manual/strings/#man-characters"><code>Char</code></a>, found on its own, is converted into the pattern equivalent.  While this is not true of booleans, an idiomatic way to spell <code>true</code> and <code>false</code> in JLpeg is <code>&quot;&quot;</code> and <code>S&quot;&quot;</code> respectively (read: &quot;the empty string&quot; and &quot;the empty set&quot;).  These are compiled into the same code as <code>P(true)</code> and <code>P(false)</code>.  JLpeg also defines, but does not export, <code>ε</code> for <code>P(true)</code> and <code>∅</code> for <code>P(false)</code>, and these may be used in grammars and rules as well, with <code>\varepsilon</code> (<code>\vare[TAB]</code>) and <code>\emptyset</code> (<code>\emp[TAB]</code>) respectively.</p><p>Public variable names from <code>JLpeg</code> will always refer to the values they have in the module.  Any other variable will be escaped, so it will have the expected meaning in context.</p><p>To give an example, this rule:</p><pre><code class="language-julia hljs">@rule :a ← &quot;foo&quot; *  [S&quot;123&quot; | &quot;abc&quot;^0]^1</code></pre><p>Is equivalent to this expression:</p><pre><code class="language-julia hljs">a = :a ← P(&quot;foo&quot;) * Cg(S(&quot;123&quot;) | P(&quot;abc&quot;)^0)^1</code></pre><p>Although the definitions of the operators and string macros would allow this reduction:</p><pre><code class="language-julia hljs">a = :a ← P&quot;foo&quot; * Cg(S&quot;123&quot; | &quot;abc&quot;^0)^1</code></pre><p>Which is a bit less cumbersome (we try).  Note that the <code>@rule</code> form doesn&#39;t require the importation of <code>@S_str</code>, or any other exported name, thanks to the nature of Julia macros.  You may always use any form of a pattern in <code>@rule</code> or <code>@grammar</code>, all of these are equivalent: <code>P(&quot;string&quot;)</code>, <code>P&quot;string&quot;</code>, and <code>&quot;string&quot;</code>.</p><h4 id="A-Sample-Grammar"><a class="docs-heading-anchor" href="#A-Sample-Grammar">A Sample Grammar</a><a id="A-Sample-Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#A-Sample-Grammar" title="Permalink"></a></h4><p>A classic example of a task forever beyond the reach of regular expressions is balancing parentheses, with JLpeg this is easy:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar parens begin
           :par ← :s * !1
           :s ← (:b | (!S&quot;()&quot; * 1))^1
           :b ← &#39;(&#39; * :s * &#39;)&#39;
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;(these (must) balance)&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;these (must) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;these (must) balance<span class="sgr31">)</span>&quot;, 22)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must) balanc<span class="sgr31">e</span>&quot;, 22)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must) balance))&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must) balance)<span class="sgr31">)</span>&quot;, 24)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(parens, &quot;(these (must))) balance)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;(these (must))<span class="sgr31">)</span> balance)&quot;, 16)</code></pre><p><code>!1</code> is our equivalent of <code>$</code> in regex, a pattern which only succeeds at the end of input. <code>1</code> will match a single Unicode codepoint, and <code>!</code> is negative lookahead.  The line-oriented equivalent of <code>$</code> is <code>~&quot;\n&quot;</code>.</p><p>The <code>@grammar</code> macro doesn&#39;t define variable names for the rules, only the grammar name given before the expression block.  The first rule is always the start rule.  As the example shows, it doesn&#39;t necessarily match the variable name, although of course it may.</p><h2 id="Captures"><a class="docs-heading-anchor" href="#Captures">Captures</a><a id="Captures-1"></a><a class="docs-heading-anchor-permalink" href="#Captures" title="Permalink"></a></h2><p>A <a href="reference/#JLpeg.PegMatch"><code>PegMatch</code></a> defaults to the longest <a href="https://docs.julialang.org/en/v1/base/strings/#Base.SubString"><code>SubString</code></a> when no captures are provided, or when the pattern succeeds but all captures within fail.  To capture only the substring(s) of interest, use <code>C(patt)</code> or just make a tuple <code>(patt,)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; match(&quot;&quot; &gt;&gt; (P&quot;56&quot;,), &quot;1234567&quot;)
PegMatch([&quot;56&quot;])</code></pre><p>This matches the empty string, fast-forwards to the first 56, and captures it.  Note that the pattern is <code>(P&quot;56&quot;,)</code>, a tuple, not a group; this is syntax sugar for <code>P(&quot;&quot;) &gt;&gt; C(P(&quot;56&quot;))</code>.  The capture can receive a key, which may be either a Symbol or a String: <code>(P&quot;56&quot;, :fiftysix)</code> or <code>(P&quot;56&quot;, &quot;fifty six&quot;)</code>.</p><table><tr><th style="text-align: right">[❓]</th><th style="text-align: left">Operation</th><th style="text-align: left">What it produces</th></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>C(patt [, key])</code>,</td><td style="text-align: left">captures the substring of <code>patt</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>(patt,)</code></td><td style="text-align: left">same as above, note the comma!</td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>(patt, key)</code></td><td style="text-align: left"><code>key</code> may be <code>:symbol</code> or <code>&quot;string&quot;</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>Cg(patt [, key])</code>,</td><td style="text-align: left">captures a Vector of values produced by <code>patt</code>,</td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>[patt], [patt, key]</code></td><td style="text-align: left">optionally tagged with <code>key</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>Cp()</code></td><td style="text-align: left">captures <code>&quot;&quot;</code> so <code>PegMatch.offsets</code> has the position</td></tr><tr><td style="text-align: right">[🔶]</td><td style="text-align: left"><code>Cc(any)</code></td><td style="text-align: left">places <code>any</code> in <code>.captures</code> at the current offset</td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: left"><code>Cr(patt [, key])</code></td><td style="text-align: left">Range of indices [start:end] of <code>patt</code>, optional <code>key</code></td></tr></table><p>Some more examples:</p><pre><code class="language-julia-repl hljs">julia&gt; @rule :cap123 ← [((S&quot;123&quot;^1,) | R&quot;az&quot;^1)^1];

julia&gt; match(cap123, &quot;abc123zyz123def&quot;)
PegMatch([[&quot;123&quot;, &quot;123&quot;]])

julia&gt; @rule :cap_pos ← [((S&quot;123&quot;^1,) | R&quot;az&quot;^1 * Cp())^1];

julia&gt; match(cap_pos, &quot;abc123zyz123def&quot;)
PegMatch([[4, &quot;123&quot;, 10, &quot;123&quot;, 16]])

julia&gt; @rule :capABC ← [((S&quot;ABC&quot;^1,) | R&quot;az&quot;^1)^1, :capABC];

julia&gt; match(capABC, &quot;abcBCAzyzCCCdef&quot;)
PegMatch([:capABC =&gt; [&quot;BCA&quot;, &quot;CCC&quot;]])</code></pre><p>The form in <code>:capABC</code>, where the rule is grouped as a capture and given a symbol which is the same as the rule name, is extremely common and gets its own shorthand:</p><pre><code class="language-julia-repl hljs">julia&gt; @rule :capABC &lt;--&gt; ((S&quot;ABC&quot;^1,) | R&quot;az&quot;^1)^1;

julia&gt; match(capABC, &quot;abcBCAzyzCCCdef&quot;)
PegMatch([:capABC =&gt; [&quot;BCA&quot;, &quot;CCC&quot;]])</code></pre><p>With both <code>⟷</code> and <code>↔︎</code> as synonyms, these are <code>\longleftrightarrow</code> and <code>\:left_right_arrow:</code> respectively.</p><h2 id="Actions"><a class="docs-heading-anchor" href="#Actions">Actions</a><a id="Actions-1"></a><a class="docs-heading-anchor-permalink" href="#Actions" title="Permalink"></a></h2><p>A pattern may be modified with an action to be taken, either at runtime, or, more commonly, once the match has completed.  Here&#39;s a summary of the available actions, which we will describe in some detail in this section.</p><table><tr><th style="text-align: right">[✅]</th><th style="text-align: right">Action</th><th style="text-align: left">Consequence</th></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>A(patt, λ)</code>,</td><td style="text-align: left">captures the return value of <code>λ</code>, as applied</td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>patt &lt;| λ</code></td><td style="text-align: left">to the captures in <code>patt</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>Q(patt, λ)</code></td><td style="text-align: left">tests the substring of <code>patt</code> with <code>λ(str)::Bool</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>Avm!(patt, λ)</code></td><td style="text-align: left">if <code>patt</code> matches, calls <code>λ(vm)::Bool</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>M(patt, :label)</code></td><td style="text-align: left"><code>M</code>ark a the region of <code>patt</code> for later reference</td></tr><tr><td style="text-align: right">[✅️]</td><td style="text-align: right"><code>K(patt, :label, op)</code></td><td style="text-align: left">chec<code>K</code> <code>patt</code> against the last mark with <code>op</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>T(:label)</code>,</td><td style="text-align: left">fail the match and throw <code>:label</code></td></tr><tr><td style="text-align: right">[✅]</td><td style="text-align: right"><code>patt % :label</code></td><td style="text-align: left">shorthand for <code>patt | T(:label)</code></td></tr></table><p>The use of <code>&lt;|</code> is meant to be mnemonic of <a href="https://docs.julialang.org/en/v1/manual/functions/#Function-composition-and-piping"><code>|&gt;</code></a> for ordinary piping (and shares its usefully low precedence), without pirating the meaning of the pipe operator.  This way <code>patt |&gt; λ</code> will do the expected thing, <code>λ(patt)</code>.</p><p><code>A</code> acts on captures.  It works like a group capture, taking the substring of <code>patt</code>, or if <code>patt</code> contains captures, it receives those captures as a <a href="https://docs.julialang.org/en/v1/base/base/#Core.Vararg"><code>Vararg</code></a>, and the return value is inserted into the capture vector, without splatting.  In the current implementation this only happens after a match is completed, but future releases may choose to evaluate some captures earlier. Accordingly, <code>λ</code> passed to <code>A</code> should be free of side effects.</p><p><code>Q</code>, a &quot;query&quot; action, happens during the match, as soon as <code>patt</code> is matched.  It receives the region matched by <code>patt</code> as a SubString, and must return a <code>Bool</code>, which determines if that pattern succeeds or fails.</p><p>As an example, here&#39;s a use of <code>Q</code> to match strings of digits divisible by 3 in base 10.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bythree(str) = parse(Int, str) % 3 == 0</code><code class="nohighlight hljs ansi" style="display:block;">bythree (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mthree = Q(R&quot;09&quot;^1, bythree);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(mthree, &quot;333&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;333&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(mthree, &quot;335&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;<span class="sgr31">3</span>35&quot;, 1)</code></pre><p>While this kind of inline validation can be useful, <code>Q</code> can be put to more interesting uses.  With care, and some closed-over state, this can be used to handle the <a href="https://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar">context sensitivity of parsing C</a>, or other languages in which the meaning of a &#39;token&#39; changes based on its definition. The resulting parser would not be reentrant, which I don&#39;t find completely satisfactory.  I hope to provide a more durable solution in a later release.</p><p><code>Q</code> only takes the actual SubString of <code>patt</code>, and it is a runtime error for <code>patt</code> to have any captures.  This is for clarity of semantics as well as performance.  A future release may change this behavior, either by extending the semantics of <code>Q</code> or adding another action, and this also ensures that such a feature won&#39;t change the behavior of valid patterns.  Note that <code>Q</code> is not itself a capture, and it may be contained within as many levels of capturing as you would like.</p><p><code>Avm!</code> also calls a provided <code>λ</code> if <code>patt</code> matches, but instead of being provided with a SubString, the argument is the entire <a href="internals/#JLpeg.VMState"><code>VMState</code></a>.  The function must return a boolean, which as usual is the success or failure of the pattern.  The obvious use for this action is debugging, or setting resource limits on a parser (for example, checking the depth of <code>vm.stack</code>), this is also the suggested way to yield a parser running inside a Task.  The internals of the VM are documented, but aren&#39;t considered part of JPpeg&#39;s public interface, so if you succumb to the temptation to use this power for some sort of fancy hack, I suggest writing tests which confirm that whatever internals that hack relies on continue to function as expected. Caveat lector!</p><p>Mostly, I expect users will be content to use <code>Q</code> to provide arbitrary runtime behavior to a pattern, or if there&#39;s a need to compare two regions of the string, the mark and check system, described next.</p><h3 id="Marks-and-Checks"><a class="docs-heading-anchor" href="#Marks-and-Checks">Marks and Checks</a><a id="Marks-and-Checks-1"></a><a class="docs-heading-anchor-permalink" href="#Marks-and-Checks" title="Permalink"></a></h3><p>Validation and parsing of strings frequently requires comparison between two substrings.  For our example, let&#39;s consider this toy XML tag grammar.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar xmltag begin
           :doc ← :tags * !1
           :tags ← :opentag * :tags^0 * :closetag
           :opentag ← &quot;&lt;&quot; * R&quot;az&quot;^1 * &quot;&gt;&quot;
           :closetag ← &quot;&lt;/&quot; * R&quot;az&quot;^1 * &quot;&gt;&quot;
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(xmltag, &quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(xmltag, &quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;&lt;a&gt;&lt;b&gt;&lt;/b<span class="sgr31">&gt;</span>&quot;, 11)</code></pre><p>So far so good! We&#39;ve got a nice recursive tag matcher, without <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">summoning Zalgo</a>.  One problem though: it allows any close tag to match any open tag.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(xmltag, &quot;&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;&quot;])</code></pre><p>To solve this, we have the mark and check mechanism. Let&#39;s rewrite the grammar to use them.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar xmltag begin
           :doc ← :tags * !1
           :tags ← :opentag * :tags^0 * :closetag
           :opentag ← &quot;&lt;&quot; * M(R&quot;az&quot;^1, :tag) * &quot;&gt;&quot;
           :closetag ← &quot;&lt;/&quot; * K(R&quot;az&quot;^1, :tag) * &quot;&gt;&quot;
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(xmltag, &quot;&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;&lt;a&gt;&lt;b&gt;&lt;/<span class="sgr31">a</span>&gt;&lt;/b&gt;&quot;, 10)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(xmltag, &quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;])</code></pre><p>That&#39;s more like it!  This mechanism allows for a fully declarative PEG grammar which matches well-formed XML.  It&#39;s also applicable to Python-style indentation, Lua&#39;s long strings, and much more.</p><p><code>K</code> has a two-argument form (shown), where the check confirms that the two substrings are identical.  In the three-argument form, a function may be provided, which must have the signature <code>(marked::AbstractString, checked::AbstractString)::Bool</code>, with the result of calling the function on the regions of interest used to pass or fail the match.  This may also be written in <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments">do syntax</a>.</p><p>For the most common comparisons, <code>JLpeg</code> provides several built-ins, which may be invoked by providing these symbols as the third argument.  These don&#39;t have to allocate SubStrings or look up a function, and should always be preferred for what they do.</p><table><tr><th style="text-align: left">Built-in</th><th style="text-align: left">Match when</th></tr><tr><td style="text-align: left"><code>:(==)</code></td><td style="text-align: left">Regions are identical</td></tr><tr><td style="text-align: left"><code>:length</code></td><td style="text-align: left">Regions have the same length</td></tr><tr><td style="text-align: left"><code>:close</code></td><td style="text-align: left">There is a mark with this tag</td></tr><tr><td style="text-align: left"><code>:always</code></td><td style="text-align: left">Whether the mark exists or not</td></tr><tr><td style="text-align: left"><code>:gt</code></td><td style="text-align: left">length(r2) &gt; length(r1)</td></tr><tr><td style="text-align: left"><code>:lt</code></td><td style="text-align: left">length(r2) &lt; length(r1)</td></tr><tr><td style="text-align: left"><code>:gte</code></td><td style="text-align: left">length(r2) ≥ length(r1)</td></tr><tr><td style="text-align: left"><code>:lte</code></td><td style="text-align: left">length(r2) ≤ length(r1)</td></tr></table><p>The builtin <code>:(==)</code> is the default used in the two-argument form of <a href="reference/#JLpeg.K"><code>K</code></a>.  The length comparisons in the table may look backward, but are easy to remember in practice: <code>K(patt, :tag, :gt)</code> means &quot;this is greater than that&quot;, and so on.  These are abbreviations and not symbols, because, for one example, <code>K(patt, :tag, &gt;)</code> is a perfectly valid check, but will use lexicographic comparison (as always with strings and <code>&gt;</code>), not length comparison.  <code>:(==)</code> is identical in meaning to <code>==</code> in this context, but may be safely elided.</p><p>Note that all of the length-examining builtins use byte width, or codeunits. Not codepoints, graphemes, or <a href="https://docs.julialang.org/en/v1/base/strings/#Base.Unicode.textwidth"><code>textwidth</code></a>.  This is the fastest of the options and probably the least surprising.  The <code>length</code> in codepoints was considered and rejected; considered because Julia uses it as the standard concept of string length, rejected for a few reasons.  One, the regions under comparison have already been verified with patterns, so they aren&#39;t unknowns. Two, both Julia and JLpeg allow invalid UTF-8 in string types, and while the behavior of <code>length</code> on invalid UTF-8 is defined, it&#39;s borderline useless in this context. Three, it would be treated as grapheme length, which it emphatically is not, creating code which works sometimes but not consistently.</p><p>Bespoke comparisons based on some other standard may always be employed as user-provided check functions.</p><p>With the exception of <code>:always</code>, a check will fail if there is no mark with the same key.  This includes user-provided functions, which won&#39;t trigger if a mark isn&#39;t found. All checks, <em>including</em> <code>:always</code>, are only performed if the enclosed pattern succeeds.  If your comparison doesn&#39;t rely on a prior region, you want <code>Q</code>, not <code>K</code>.</p><p>Marks and checks are independent of the capture mechanism, but since the regions of interest are frequently worth capturing, we provide <a href="reference/#JLpeg.CM"><code>CM(patt, :sym)</code></a> as a shorthand for <code>C(M(patt, :sym), :sym)</code>, and <a href="reference/#JLpeg.CK"><code>CK(patt, :sym, check)</code></a> as shorthand for <code>C(K(patt, :sym, check), :sym)</code>.</p><h4 id="Checks-and-Predicates"><a class="docs-heading-anchor" href="#Checks-and-Predicates">Checks and Predicates</a><a id="Checks-and-Predicates-1"></a><a class="docs-heading-anchor-permalink" href="#Checks-and-Predicates" title="Permalink"></a></h4><p>Successful checks will remove the corresponding mark, unless they&#39;re inside predicates, <code>~</code> or <code>!</code>.  The &quot;exception to the exception&quot; is <code>:always</code>, which, given the semantics of the name, and the fact that it exists entirely to remove marks, we felt should do what it says on the label.</p><p>This differing behavior inside predicates is the better semantic, since it allows lookahead for a checked mark which is later consumed.</p><p>As an example, we&#39;ll show a grammar for <a href="https://www.inf.puc-rio.br/~roberto/lpeg/lpeg.html#ex">Lua&#39;s long strings</a>.  This serves to illustrate both the motive for our choice of check behavior inside predicates, and the reason for adding JLpeg&#39;s innovative mark and check mechanism. LPeg can provide equivalent functionality for many cases, using a more general but somewhat cumbersome mechanism, the &quot;match-time capture&quot;, with no direct equivalent in JLpeg.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar longstr begin
           :str ← :open * :body * :close
           :open ← &#39;[&#39; * M(&quot;=&quot;^0, :equals) * &#39;[&#39;
           :body ← ((!:close * 1)^0, :string)
           :close ← &#39;]&#39; * K(&quot;=&quot;^0, :equals) * &#39;]&#39;
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(longstr, &quot;[[]]&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([:string =&gt; &quot;&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(longstr, &quot;[[long strings]]&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([:string =&gt; &quot;long strings&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(longstr, &quot;[==[end with a ]=] token]==]&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([:string =&gt; &quot;end with a ]=] token&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(longstr, &quot;[==[the equals must balance]=]&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;[==[the equals must balance]=<span class="sgr31">]</span>&quot;, 31)</code></pre><p>Lua&#39;s long strings are a nice bit of syntax, because they have the enclosure property: it is always possible to wrap a literal string as a program string, without modifying the string itself, because the equals signs in e.g. <code>[===[</code> must be matched with <code>]===]</code>.  I wish Julia had a string syntax which functions the same way.</p><p>We see that the <code>:body</code> rule contains <code>(!:close * 1)^0</code>, a pattern which experienced PEG users will recognize as matching zero or more characters, so long as the lookahead doesn&#39;t match the <code>:close</code> rule.</p><p>Because the negative-lookahead <code>:close</code> always matches the <code>:close</code> rule first on the closing region, if <code>K</code> didn&#39;t behave differently inside predicates, this would consume the mark, so the <code>:close</code> in the <code>:str</code> rule would always fail.</p><h4 id="Limitation-and-Performance"><a class="docs-heading-anchor" href="#Limitation-and-Performance">Limitation and Performance</a><a id="Limitation-and-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Limitation-and-Performance" title="Permalink"></a></h4><p>Marks and checks come with an <strong>important limitation</strong>: they must not contain other marks and checks.  Any other pattern is ok, including captures and all other actions. A future version of JLpeg may check for this condition and refuse to compile, the current behavior will silently corrupt your parse.  The author&#39;s opinion is that this is no limitation in practice, after all, one might match the longer region and perform whatever inner checks are desired.  If you find yourself with a real-world grammar which would benefit from nested marks, feel free to open an issue, and we can decide if the complexity, performance impact, and unclear semantics (does an inner mark come before, or after, its enclosing mark?) is worth it.</p><p>Note that marks are only removed once a corresponding check succeeds, and grammars or strings which don&#39;t close their marks will leave them on the mark stack.  This is mostly harmless, the worst that can come of it is JLpeg throwing an <code>InexactError</code> once there are more than <code>typemax(UInt16)</code> marks on the stack (assuming the OS can provide adequate amounts of heap), but it&#39;s certainly possible to create bad performance.  For example, by stacking up a bunch of mark <code>:a</code> while checking for mark <code>:b</code>, every check will be forced to fruitlessly look for the nonexistent mark on a growing stack of marks.  It takes some real effort to produce a grammar which will do this, however.</p><p>If you have a grammar where some paired regions may be implicitly closed, you can use <code>K(patt, :tag, :always)</code> to close the mark by fiat; this check succeeds whether the mark exists or not.  If you want the check to fail if the mark doesn&#39;t exist, use <code>K(patt, :tag, :close)</code> instead.  This comes up in Markdown parsing, where, for example, <code>**</code> for emphasis is allowed to end when the paragraph ends, without needing to be closed.</p><p>Final note: this thorough discussion might leave some with the impression that marks and checks aren&#39;t performant, are tricky, to be avoided in practice, etc.  Fear not! Typical uses will consume marks nearly as fast as they&#39;re generated, and it&#39;s rare for marks to overlap, that is, normally the check will be compared against the latest mark.  To cite our XML example, the mark stack will be as deep as the tags are nested, comparisons are always against the top mark, and any mismatch fails the entire parse. This has the same time complexity as a grammar which doesn&#39;t validate that tags match, with a small added constant factor which is well-used.</p><p>Grammars normally have tidy properties, forming a neat heirarchical tree in which options either close themselves by succeeding or are backtracked off the stack (and of course, marks within a choice which fails are removed during backtracking). Proper use of <code>M</code> and <code>K</code> requires the author to balance this mechanism on their own.  While it&#39;s possible to write a self-balancing analogue of this mechanism, we felt that the added flexibility was more than worth the additional care which must be taken. Consider what would be involved in writing the <code>longstr</code> grammar above, if <code>:close</code> had to be structurally balanced against <code>:open</code> somehow.</p><p>Practical use of mark and check is as fast as it reasonably can be, and enables recognition of many common patterns in strings.</p><h3 id="Throws-and-Recovery"><a class="docs-heading-anchor" href="#Throws-and-Recovery">Throws and Recovery</a><a id="Throws-and-Recovery-1"></a><a class="docs-heading-anchor-permalink" href="#Throws-and-Recovery" title="Permalink"></a></h3><p>The greatest challenge for good parsing has always been error reporting and recovery. With old-school <a href="https://www.wikiwand.com/en/Yacc">lex and yacc</a>, the conventional wisdom was to develop the grammar for a language or DSL using the compiler-compiler toolkit, to assure that the grammar is actually in a useful context-free class, then handroll a recursive-descent parser for production use, in order to provide users with useful error messages when they inevitably create syntax errors.</p><p><a href><code>JLpeg</code></a>, being a PEG parser, is a formalization of the classic recursive-descent parsing strategy.  It includes a mechanism pioneered by <a href="https://github.com/sqmedeiros/lpeglabel">lpeglabel</a>, modestly improved in our implementation, which allows a pattern to throw a specific error when an expected aspect of parsing is violated.</p><p><code>T(:label)</code> fails the match, records the position of that failure, and throws <code>:label</code>.  If there is a rule by that name, it is attempted for error recovery, otherwise <code>:label</code> and the error position are attached to the <code>PegFail</code> struct, in the event that the whole pattern fails.  The label <code>:default</code> is reserved by JLpeg for reporting failure of patterns which didn&#39;t otherwise throw a label.</p><p>Consider a simplified pattern for matching single-quoted strings:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @rule :string ← &quot;&#39;&quot; * (!&quot;&#39;&quot; * 1)^0 * &quot;&#39;&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(string, &quot;&#39;a string&#39;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;&#39;a string&#39;&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(string, &quot;&#39;not a string&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;&#39;not a strin<span class="sgr31">g</span>&quot;, 14)</code></pre><p>We do mark the point of failure, which is better than average; a normal PEG or parser combinator will silently fail to match, without informing the user of where. But we can do better with throws.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @rule :string  ←  &quot;&#39;&quot; * (!&quot;&#39;&quot; * 1)^0 * (&quot;&#39;&quot; % :badstring)</code><code class="nohighlight hljs ansi" style="display:block;">JLpeg.PRule(val→[JLpeg.PSeq], IVec[]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(string, &quot;&#39;not a string&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;&#39;not a strin<span class="sgr31">g</span>&quot;, 14, :badstring)</code></pre><p>This provides us both with the point of failure, and the cause, data which can be used to provide a helpful error message to the user.</p><p>A Throw with a matching rule will attempt that rule on throw, if this succeeds, the parse continues.  This can be used to embed errors while continuing to check the validity of the grammar, as in this example.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @grammar strmatch begin
           :strings ← &quot; &quot;^0 * &quot;&#39;&quot; * (!S&quot;&#39;\n&quot; * 1)^0 * (&quot;&#39;&quot; % :missedend) * :strings^0 * !1
           :missedend ← (&quot;\n&quot;, :str_newline_error)
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(strmatch, &quot;&#39;a string&#39; &#39;another string&#39;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([&quot;&#39;a string&#39; &#39;another string&#39;&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(strmatch, &quot;&#39;a string\n &#39;another string&#39;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegMatch([:str_newline_error =&gt; &quot;\n&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; match(strmatch, &quot;&#39;a string&#39; &#39;another string&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PegFail(&quot;&#39;a string&#39; &#39;another strin<span class="sgr31">g</span>&quot;, 27, :missedend)</code></pre><p>Here we have a grammar matching at least one single-quoted string, which may not contain a literal newline. If we fail to match a string, the <code>:missedend</code> rule looks for a newline, which it captures and tags, enabling the parse to continue.  Note that when the recovery rule doesn&#39;t match, the label remains in place, and will be provided if the whole parse fails at that location.</p><p>Subsequent code can look for <code>:str_newline_error</code>, or any number of such error-signalling keys.  Since a <a href="https://docs.julialang.org/en/v1/base/strings/#Base.SubString"><code>SubString</code></a> has its start point in the <code>.offset</code> field, this may be used to inform the user where the missing close quote belongs.</p><p>Throws, like checks, behave differently inside predicates: they become a normal failure, without setting the label or trying any recovery rule.  Pattern failure in lookahead has a different meaning than failure to consume input, generally speaking, and this little tweak allows more patterns to be used both for lookahead and ordinary matching without having to write them twice.</p><h2 id="Working-With-Matched-Data"><a class="docs-heading-anchor" href="#Working-With-Matched-Data">Working With Matched Data</a><a id="Working-With-Matched-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Working-With-Matched-Data" title="Permalink"></a></h2><p><a href="reference/#JLpeg.PegMatch"><code>PegMatch</code></a> implements the interface of AbstractMatch, and as such, it is intentionally structured to be similar to <a href="https://docs.julialang.org/en/v1/base/strings/#Base.RegexMatch"><code>RegexMatch</code></a> from the standard library.  PEGs are a far richer and more sophisticated tool than regexen, however: a named capture might appear many times, captures can be grouped, those groups may have groups, with captures, having names, and so on.</p><p>Our intention is that simple matching will behave in a familiar way, with additional methods provided for more complex scenarios.  Let&#39;s consider a simple rule with some captures.</p><pre><code class="language-julia-repl hljs">julia&gt; @rule :baddate ← (R&quot;09&quot;^[4], :year) * &quot;-&quot; * (R&quot;09&quot;^[2:2],) * &quot;-&quot; * (R&quot;09&quot;^[2], :day);

julia&gt; date = match(baddate, &quot;2024-01-10&quot;)
PegMatch([:year =&gt; &quot;2024&quot;, &quot;01&quot;, :day =&gt; &quot;10&quot;])</code></pre><p>The rule name is because this is certainly not how you should parse a date!  Note the two equivalent ways of specifying a definite number of repetitions, <code>[2]</code> is preferred.</p><p>Let&#39;s illustrate how to work with this.</p><pre><code class="language-julia-repl hljs">julia&gt; date == [:year =&gt; &quot;2024&quot;, &quot;01&quot;, :day =&gt; &quot;10&quot;]
true

julia&gt; [:year =&gt; &quot;2024&quot;, &quot;01&quot;, :day =&gt; &quot;10&quot;] == date
true</code></pre><p>A <a href="reference/#JLpeg.PegMatch"><code>PegMatch</code></a> is <a href="https://docs.julialang.org/en/v1/base/math/#Base.%3A%3D%3D"><code>==</code></a> to a <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.AbstractVector"><code>Vector</code></a> with the same contents.  However, note that a <code>PegMatch</code> uses default hash equality:</p><pre><code class="language-julia-repl hljs">julia&gt; hash(date) == hash([:year =&gt; &quot;2024&quot;, &quot;01&quot;, :day =&gt; &quot;10&quot;])
false</code></pre><p>This is somewhat at variance with <a href="https://docs.julialang.org/en/v1/base/base/#Base.hash">doctrine</a>, but we feel it&#39;s the correct choice here.</p><p>Next, let&#39;s look at iteration and indexing.</p><pre><code class="language-julia-repl hljs">julia&gt; date[:day]
&quot;10&quot;

julia&gt; date[3]
&quot;10&quot;

julia&gt; keys(date)
3-element Vector{Any}:
  :year
 2
  :day

julia&gt; collect(date)
3-element Vector{Any}:
 &quot;2024&quot;
 &quot;01&quot;
 &quot;10&quot;

julia&gt; collect(eachindex(date))
3-element Vector{Int64}:
 1
 2
 3

julia&gt; collect(pairs(date))
3-element Vector{Pair{A, SubString{String}} where A}:
 :year =&gt; &quot;2024&quot;
     2 =&gt; &quot;01&quot;
  :day =&gt; &quot;10&quot;

julia&gt; collect(enumerate(date))
3-element Vector{Tuple{Int64, Any}}:
 (1, &quot;2024&quot;)
 (2, &quot;01&quot;)
 (3, &quot;10&quot;)</code></pre><p>Default iteration will get you the matches, <a href="https://docs.julialang.org/en/v1/base/collections/#Base.pairs"><code>pairs</code></a> uses the name of the capture when there is one, if a capture has a name, that can be used to index it, or the position in the Vector.</p><p>So far so good, what happens if a named capture matches more than once?</p><pre><code class="language-julia-repl hljs">julia&gt; @rule :abcs ← ((R&quot;az&quot;^1, :abc) | &quot;123&quot;)^1;

julia&gt; letters = match(abcs, &quot;abc123def123ghi123&quot;)
PegMatch([:abc =&gt; &quot;abc&quot;, :abc =&gt; &quot;def&quot;, :abc =&gt; &quot;ghi&quot;])

julia&gt; letters[:abc]
&quot;abc&quot;

julia&gt; keys(letters)
3-element Vector{Any}:
  :abc
 2
 3

julia&gt; collect(pairs(letters))
3-element Vector{Pair{Symbol, SubString{String}}}:
 :abc =&gt; &quot;abc&quot;
 :abc =&gt; &quot;def&quot;
 :abc =&gt; &quot;ghi&quot;</code></pre><p>As you can see, the <em>first</em> match with that name is the indexable one, and therefore, is the only time <code>:abc</code> appears in <code>keys</code>, while all matches have their name in <code>pairs</code>, or, if anonymous, their index.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 5 February 2024 20:15">Monday 5 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
