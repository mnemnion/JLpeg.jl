var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Core-API","page":"Reference","title":"Core API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The basic structure of recognition in JLPeg is a Pattern.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Pattern","category":"page"},{"location":"reference/#JLpeg.Pattern","page":"Reference","title":"JLpeg.Pattern","text":"Container for various patterns and grammars. Always has val, which may be primitive or a PVector, and code, an IVector. Some patterns have a field unique to that pattern type.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Reference","title":"Reference","text":"These are created in a wide variety of ways, all based on three functions, P, S, and R, with the rest of the work done with a great quantity of operator overloading.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.PegMatch\nJLpeg.PegFail\nJLpeg.PegError","category":"page"},{"location":"reference/#JLpeg.PegMatch","page":"Reference","title":"JLpeg.PegMatch","text":"PegMatch <: AbstractMatch\n\nA type representing a successful match of a Pattern on a string.  Typically returned from the match function.  PegFail is the atypical return value.\n\nA PegMatch is equal (==) to a Vector if the captures are equal to the Vector.\n\nProperties:\n\nsubject::AbstractString:  Stores the string matched.\nfull::Bool:  Whether the match is of the entire string.\ncaptures::Vector:  Contains any captures from matching patt to subject.   This can in principle contain anything, as captures may call functions, in which   case the return value of that function becomes the capture.  For more   information, consult the JLPeg documentation, and the docstrings for C, Cg,   Cc, A, and Anow.\noffsets::Vector{Int}:, provided for compatibility with AbstractMatch.  SubStrings contain their own offsets, so this is unnecessary for normal work,  but we JIT it for match.offsets.  It then consists of the indices at which the  outer layer of captures may be found within the subject.\npatt::Pattern: The pattern matched against the subject.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.PegFail","page":"Reference","title":"JLpeg.PegFail","text":"PegFail\n\nReturned on a failure to match(patt:Pattern, subject::AbstractString).\n\nProperties\n\nsubject::AbstractString:  The string that we failed to match on.\nerrpos: The position at which the pattern ultimately failed to match.\nlabel::Symbol: Info about the failure provided by T(::symbol), defaulting to       :default if the pattern fails but not at a throw point, or if no throws are       provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.PegError","page":"Reference","title":"JLpeg.PegError","text":"PegError(msg) <: Exception\n\nAn error while constructing a Pattern.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Pattern-Matching","page":"Reference","title":"Pattern Matching","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"match\nJLpeg.compile!","category":"page"},{"location":"reference/#Base.match","page":"Reference","title":"Base.match","text":"match(patt::Pattern, subject::AbstractString)::Union{PegMatch, PegFail}\n\nMatch patt to subject, returning a PegMatch implementing the expected interface for its supertype AbstractMatch, or a PegFail with useful information about the failure.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.compile!","page":"Reference","title":"JLpeg.compile!","text":"compile!(patt::Pattern)::Pattern\n\nCompile a Pattern.\n\nTranslate the Pattern to Instruction codes, appending them to the code field and returning same.  Performs various optimizations in the process.\n\nIn most cases, the return value of compile! is the same Pattern passed in. The exceptions are special cases of primitive types, but be sure to reassign the return value to the variable bound to the original for the general case.\n\n\n\n\n\ncompile!(patt::PGrammar)::Pattern\n\nCompiles and prepares a Grammar.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Constructing-Patterns","page":"Reference","title":"Constructing Patterns","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Patterns are built by combining the products of these constructors into more complex Patterns.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.P\nJLpeg.@P_str\nJLpeg.S(s::AbstractString)\nJLpeg.@S_str\nR(::AbstractString)\nR(::AbstractChar, ::AbstractChar)\nJLpeg.@R_str\nJLpeg.B","category":"page"},{"location":"reference/#JLpeg.P","page":"Reference","title":"JLpeg.P","text":"P(p::Union{AbstractString,AbstractChar,Integer,Bool,Symbol})::Pattern\n\nCreate a Pattern.\n\nIf p is a String or Char, this matches that string or character.\nIf p is a positive Integer, it matches that many characters.\nIf p is true, the rules succeeds, if false, the rule fails.\nIf p is a Symbol, this represents a call to the rule with that name.\nIf p is a negative Integer, matches if that many characters remain, consumes no input.\nIf p is already a Pattern, it is simply returned.\n\nExamples\n\njulia> match(P(\"func\"), \"funci\")\nPegMatch([\"func\"])\n\njulia> match(P(3), \"three\")\nPegMatch([\"thr\"])\n\njulia> match(P(true), \"pass\")\nPegMatch([\"\"])\n\njulia> match(P(false), \"fail\")\nPegFail(\"fail\", 1)\n\njulia> match(P('👍'), \"👍\")\nPegMatch([\"👍\"])\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.@P_str","page":"Reference","title":"JLpeg.@P_str","text":"P\"str\"\n\nCalls P(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.S-Tuple{AbstractString}","page":"Reference","title":"JLpeg.S","text":"S(s::AbstractString)\n\nCreate a Pattern matching any charcter in the string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.@S_str","page":"Reference","title":"JLpeg.@S_str","text":"S\"str\"\n\nCalls S(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.R-Tuple{AbstractString}","page":"Reference","title":"JLpeg.R","text":"R(s::AbstractString)\n\nCreate a Pattern matching every character in the range from the first to the second character.  s must be two codepoints long, and the first must be lower-valued than the second.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.R-Tuple{AbstractChar, AbstractChar}","page":"Reference","title":"JLpeg.R","text":"R(a::AbstractChar, b::AbstractChar)\n\nMatch any character in the range a to b, inclusive.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.@R_str","page":"Reference","title":"JLpeg.@R_str","text":"R\"str\"\n\nCalls R(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.B","page":"Reference","title":"JLpeg.B","text":"B(p::Union{Pattern,AbstractString,AbstractChar,Integer})\n\nMatch patt behind the current subject index. patt must be of fixed length.  The most useful B pattern is !B(1), which succeeds at the beginning of the string, followed by B(' ') to match the start of a line.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Combinators","page":"Reference","title":"JLpeg.Combinators","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Combinators","category":"page"},{"location":"reference/#JLpeg.Combinators","page":"Reference","title":"JLpeg.Combinators","text":"JLpeg.Combinators\n\nContains all the combinator operators which shadow definitions in Base.  The module redefines these symbols, providing a fallback to the Base, and are designed not to break existing code.  The Julia compiler handles this kind of redirection well during inference, this technique is used by several packages which specialize operators for numerically-demanding tasks, without issue; we even transfer the Base docstrings.\n\nWhether or not these overloads rise to the level of piracy is debatable.  That said, we've walled them off, so that debate is not necessary.\n\nUse\n\nThe @grammar and @rule macros are able to use these operators, so you may not need them.  To import them, add this to your module:\n\nimport JLpeg.Combinators: *, -, %, |, ^, ~, !, >>, >:, inv\n\n\n\n\n\n","category":"module"},{"location":"reference/#Captures-and-Actions","page":"Reference","title":"Captures and Actions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"PEG patterns are recognizers, matching the longest prefix of the string which they're able.  Captures allow for substrings to be captured within the match, Actions perform actions at the index of the match, or on a capture.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.C\nJLpeg.Cg\nJLpeg.Cr\nJLpeg.Cc\nJLpeg.Cp\nJLpeg.A\nJLpeg.Anow\nJLpeg.T","category":"page"},{"location":"reference/#JLpeg.C","page":"Reference","title":"JLpeg.C","text":"C(patt::Pattern)\n\nCreate a capture. Matching patt with return the matched substring.\n\n\n\n\n\nC(patt::Pattern, sym::Union{Symbol,AbstractString})\n\nCreate a named capture with key :sym or \"sym\".\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cg","page":"Reference","title":"JLpeg.Cg","text":"Cg(patt::Pattern [, sym::Union{Symbol,AbstractString}])\n\nCreate a group capture, which groups all captures from P into a vector inside the PegMatch object.  If sym is provided, the group will be found at that key.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cr","page":"Reference","title":"JLpeg.Cr","text":"Cr(patt::Pattern, sym::Union{CapSym, Nothing})\n\nCaptures a UnitRange of matches in patt, optionally keyed by sym. Convenient for substitutions and annotations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cc","page":"Reference","title":"JLpeg.Cc","text":"Cc(args...)\n\nConstant capture. Matches the empty string and puts the values of args as a tuple in that place within the PegMatch captures.  If args is a Pair{Symbol,Any}, that symbol will appear as a key in the match.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cp","page":"Reference","title":"JLpeg.Cp","text":"Cp()\n\nCaptures the empty string in .captures, consuming no input.  Useful for the side effect, of storing the corresponding offset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.A","page":"Reference","title":"JLpeg.A","text":"A(patt::Pattern, fn::Function)\n\nActs as a grouping capture for patt, applying fn to a successful match with the captures as arguments (not as a single Vector). If patt contains no captures, the capture is the SubString.  The return value of fn becomes the capture; if nothing is returned, the capture (and its offset) are deleted.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Anow","page":"Reference","title":"JLpeg.Anow","text":"Anow(patt::Pattern, fn::Function)\n\nActs as a grouping capture, applying fn immediately upon a match succeeding to the captures inside patt, or the span of patt if there are no captures within it.  The return value of fn becomes the capture, but if nothing is returned, the entire pattern fails.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.T","page":"Reference","title":"JLpeg.T","text":"T(label::Symbol)\n\nThrow a failure labeled with :label.  If a rule :label exists, this will be called to attempt recovery, the success or failure of the recovery rule is then used.  Otherwise, :label and the position of T(:label) will be attached to PegFail in the event that the whole match fails.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rules-and-Grammars","page":"Reference","title":"Rules and Grammars","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The great advantage (other than composability) PEGs have over regular expressions is the ability to match recursive patterns.  These are constructed out of Rules and Grammars.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Grammar\nJLpeg.Rule\nJLpeg.@rule\nJLpeg.@grammar","category":"page"},{"location":"reference/#JLpeg.Grammar","page":"Reference","title":"JLpeg.Grammar","text":"Grammar(rule...)\n\nCreate a grammar from the provided rules.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.Rule","page":"Reference","title":"JLpeg.Rule","text":"Rule(name::Symbol, patt::Pattern)\n\nUn-sugared form of @rule, creates a rule from patt, assigning it the name name.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.@rule","page":"Reference","title":"JLpeg.@rule","text":"@rule :name ← pattern...\n\nSugared form for rule definition. Assigns the rule in-scope with the given name:\n\n# Wrong\nname = @rule :name  ←  \"foo\" | \"bar\"\n# Right\n@rule :name ← \"foo\" | \"bar\"\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.@grammar","page":"Reference","title":"JLpeg.@grammar","text":"@grammar(name, rules)\n\nSyntax sugar for defining a set of rules as a single grammar. Expects a block rules, each of which is a rule-pair as can be created with ←, or, if you must, <=.  \"string\" will be interpolated as P(\"string\"), and :symbol as P(:symbol).  Be sure to use the macro forms S\"123\" and R\"az\" for sets and ranges, which will otherwise be transformed into S(P(\"123\")), which is invalid.\n\nExample use\n\nThis simple grammar captures the first string of numbers it finds:\n\njulia> @grammar capnums begin\n            :nums  ←  (:num,) | 1 * :nums\n            :num   ←  S\"123\"^1\n        end;\n\njulia> match(capnums, \"abc123abc123\")\nPegMatch([\"123\"])\n\nThis one also captures the lowercase letters, before converting them to uppercase.\n\njulia> upper = uppercase;  # A thoroughly unhygienic macro\n\njulia> @grammar uppernums begin\n           :nums  ←  (:num,) | :abc * :nums\n           :num   ←  S\"123\"^1\n           :abc   ←  R\"az\"^1 <| upper\n       end;\n\n\njulia> match(uppernums, \"abc123abc123\")\nPegMatch([\"ABC\", \"123\"])\n\nMore extensive examples may be found in the documentation.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Dialects","page":"Reference","title":"Dialects","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"A work in progress.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.re","category":"page"},{"location":"reference/#JLpeg.re","page":"Reference","title":"JLpeg.re","text":"re : An Interpretation of LPeg's `re` module\n\nThe first dialect, intended, among other things, as a useful bootstrap of other dialects.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Generators","page":"Reference","title":"Generators","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"A PEG is a specification of a class of algorithms which are valid on a universe of strings.  While the common thing to do is use this specification to construct a recognizer for such strings, it may also be used to create generators for valid strings in that universe.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg aspires to provide a complete set of generators for our patterns. So far, we have:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.generate","category":"page"},{"location":"reference/#JLpeg.generate","page":"Reference","title":"JLpeg.generate","text":"generate(set::PSet)::String\n\nGenerate a String of all characters matched by a Set.\n\n\n\n\n\n","category":"function"},{"location":"#JLpeg:-Pattern-Matching-and-Parsing-For-Julia","page":"JLpeg Guide","title":"JLpeg: Pattern Matching and Parsing For Julia","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"CurrentModule = JLpeg\nDocTestSetup = quote\n    using JLpeg\n    import JLpeg.Combinators: *, -, %, |, ^, ~, !, >>, >:, inv\nend","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"JLpeg provides a fast Parsing Expression Grammar engine for matching patterns in strings, using a bytecode virtual machine based on the pioneering work of Roberto Ierusalimschy.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared to regular expressions, PEGs offer greater power and expressivity, being, in a sense, a formalized and extended version of the deviations from regular languages offered by production regex engines such as PCRE.  PEGs are able to parse recursive rule patterns, employ lookahead and lookbehind predicates, and avoid the sort of worst-case complexity the regex is prone to, for most useful patterns.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared with parser combinators, a more common algorithm for matching PEG grammars, the approach taken by this package is superior.  A bytecode interpreter allows several key optimizations which parser combinators do not allow; generally such libraries choose between a naive backtracking algorithm with bad time complexity, and a memorizing packrat algorithm which trades this for bad space complexity, with consequent memory pressure.  JLpeg generates programs which may be inspected and modified, and uses an innovative thrown-label pattern to allow excellent error reporting and recovery.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared with a \"compiler compiler\" such as ANTLR or the classic yacc/bison, JLpeg does not generate source code, but rather bytecode, which Julia is able to JIT into near-optimal machine code on the fly.  These systems require an imput stream to be reduced to tokens, an abstraction PEGs do not need, which allows JLpeg to parse contextually-valid grammars which cannot be readily tokenized.  PEGs are also far more suitable for scanning, captures, and other pattern-recognition tasks than these programs, which are only well-suited to parsing of full grammars, a task JLpeg also excels at.","category":"page"},{"location":"#Patterns","page":"JLpeg Guide","title":"Patterns","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Parsing Expression Grammars are built out of patterns. These begin with atomic units of recognition, and are combined into complex rules, which can call other rules, recursively, recognizing context free, and some context sensitive, languages.  LPeg, JLpeg's inspiration, uses a SNOBOL-style set of operator overloads as the basic tool for building up patterns, a practice we also follow.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Patterns and their combination are the building block of JLpeg recognition engines. They are immutable and may be freely recombined and reused, unlike either regular expressions or the parsers generated by typical compiler-compilers.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The API of JLpeg hews closely to Lpeg, with several extensions, refinements, and a more natively Julian character.","category":"page"},{"location":"#Combination","page":"JLpeg Guide","title":"Combination","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The basic operations are as follows:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Operator Description\nP(string::String) match a literal String string\nP(n::UInt) match any n characters\nP(-n) match if there are at least n characters remaining\nP(sym::Symbol) match the rule named :sym\nS(s::String) match the set of all characters in string\nR(\"xy\"), R('x','y') matches any character between x and y (Range)\nB(patt) match patt behind the cursor, without advancing\npatt^n match at least n repetitions of patt\npatt^-n match at most n repetitions of patt\npatt^[n:m] match between n and m repetitions of patt\npatt^[n] match exactly n repetitions of patt\npatt1 * patt2 match the sequence patt1 , patt2\npatt1 | patt2 match patt1 or patt2, in that order\npatt1 - patt2 match patt1 if patt2 does not match\n!patt, ¬patt negative lookahead, succeeds if patt fails\n~patt lookahead, match patt without advancing\npatt1 >> patt2 match patt1, then search the string for the next patt2.\nP(true), ε always succeed\nP(false), ∅ always fail","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"In keeping with the spirit of LPeg, P\"string\" is equivalent to P(\"string\"), and this is true for S and R as well.  These basic operations are not recursive, and without further modification merely match the longest substring recognized by the pattern.  This is sufficient to match all regular languages.","category":"page"},{"location":"#A-Note-About-Piracy","page":"JLpeg Guide","title":"A Note About Piracy","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"You will note that combining Patterns involves a great deal of operator overloading. In Julian circles, operators are presumed to have a certain contract, although this is informal and has a certain latitude.  Some of our operators comply with this expectation: * and ^ are used for concatenation and repetition for AbstractStrings, as they are with Patterns, although the meaning of repetition is broader for patterns.  Others do not: particularly egregious is !, which is expected to always return a Bool, and >: (an Action), which has no relationship to supertypes whatsoever.  | and - are justifiable, in my opinion: | is firmly grounded in tradition and a | b would be pronounced \"a or b\", while subtraction has a huge variety of meanings in mathematics; our use, as one should expect, is neither commutative nor associative. ~ and >> bear little resemblance to their ordinary meanings.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Broadly speaking, the combinator operators in JLpeg are a combination of availability, operator precedence, and mnemnonic weight, in that order.  For example, &patt is the signifier for lookahead in the PEG definition, we use ~ because it's unary, and Julia has but few unary operators.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"In any case, we shadow operators, rather than overloading the ones found in Base, and they aren't exported.  We provide JLpeg.Combinators as an easy way to bring them into scope if desired.  Most users will stick to the @rule and @grammar macros, which don't require bringing operators into scope.","category":"page"},{"location":"#Matching","page":"JLpeg Guide","title":"Matching","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"match(pattern::Pattern, string::AbstractString) will attempt to match the pattern against the string, returning a PegMatch <: AbstractMatch. In the event of a failure, it returns a PegFail, with the index of the failure at .errpos.  Note that unlike regular expressions, JLpeg will not skip ahead to find a pattern in a string, unless the pattern is so constructed.  We offer the easy shorthand \"\" >> patt to convert a pattern into its searching equivalent; P\"\" matches the empty string, and JLPeg will convert strings and numbers (but not booleans) into patterns when able.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> match(P\"123\", \"123456\")\nPegMatch([\"123\"])\n\njulia> match(P\"abc\" * \"123\", \"abc123\")\nPegMatch([\"abc123\"])\n\njulia> match(P\"abc\" | \"123\", \"123\")\nPegMatch([\"123\"])\n\njulia> match(P\"abc\"^1, \"abcabcabc\")\nPegMatch([\"abcabcabc\"])\n\njulia> match((!S\"123\" * R\"09\")^1, \"0987654321\")\nPegMatch([\"0987654\"])\n\njulia> match(\"\" >> P\"5\", \"0987654321\")\nPegMatch([\"098765\"])\n\njulia> match(~P\"abc\", \"abc123\")\nPegMatch([\"\"])\n\njulia> match(~P\"abc\", \"123abc\") # fails\nPegFail(\"123abc\", 1)","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The operators introduce a pattern 'context', where any a <op> b combination where a or b is a Pattern will attempt to cast the other argument to a Pattern when appropriate.  Generally, a MethodError may be repaired by using P on the left side of the the operator, although we can't guarantee that other method overloads for those operators might apply.  Notably, * is used for concatenation of strings, although in the JLpeg context, P\"abc\" * P\"123\" is in fact the same as P(\"abc\" * \"123\").","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This UI is adequate for light work, but the macros discussed later are cleaner to work with, defined such that P should never be necessary, although any of the public names in the JLpeg module may be used, and needn't be imported into your package to do so.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Note that, unlike regular expressions, PEG matching always starts with the first character.  Any match returned by a call to match(patt, string) will therefore be a prefix of the string, up to and including the entire string.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Most interesting uses of pattern recognition will call for more than matching the longest substring.  For those more complex cases, we have Captures and Actions.","category":"page"},{"location":"#Rules-and-Grammars","page":"JLpeg Guide","title":"Rules and Grammars","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"While simple patterns may be composed by assigning to variables and using those variable names to build up more complex patterns, this doesn't allow for recursion, which is essential for matching many strings of interest, perhaps most.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"For this purpose, we have rules, which are simply named patterns.  A rule with no references to another rule within it may be used for matching directly, while those with such references (including a reference to itself) must be composed into grammars.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"As is the PEG convention, a rule reduction uses the left arrow ←, which you can type as \\leftarrow (or in fact \\lef[TAB]), also defined as <--.  A simple grammar can look like this:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"abc_and = :a <-- P\"abc\" * (:b | P\"\")\n_123s   = :b ← P\"123\"^1 * :a\nabc123  = Grammar(abc_and, _123s)\n\nmatch(abc123, \"abc123123123abc123abc\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Although we suggest as a matter of style that a grammar use one arrow form or the other, with ← preferred.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The first rule is the start rule, which must succeed if the match is to succeed.  A grammar which is missing rules will throw a PegError, but duplicate rules are undefined behavior: currently JLpeg will compile the last rule of that name it encounters, but this behavior must not be relied upon.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The preferred way to create rules and grammars is with the macros @rule and @grammar, which avoid the tedium of decorating expressions with P entirely.  Any Integer, String, Symbol, or Char, found on its own, is converted into the pattern equivalent.  While this is not true of booleans, the idiomatic way to spell true and false in JLpeg is \"\" and S\"\" respectively, and these are compiled into the same code as P(true) and P(false).  JLpeg also defines, but does not export, ε for P(true) and ∅ for P(false), and these may be used in grammars and rules as well, with \\varepsilon (\\vare[TAB]) and \\emptyset (\\emp[TAB]) respectively.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Exported variable names from JLpeg will always refer to the values they have in the module.  Any other variable will be escaped, so it will have the expected meaning.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"To give an example, this rule:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@rule :a ← \"foo\" *  [S\"123\" | \"abc\"^0]^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Is equivalent to this expression:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"a = :a ← P(\"foo\") * Cg(S(\"123\") | P(\"abc\")^0)^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Although the definitions of the operators and string macros would allow this reduction:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"a = :a ← P\"foo\" * Cg(S\"123\" | \"abc\"^0)^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Which is a bit less cumbersome (we try).  Note that the @rule form doesn't require the importation of @S_str, or any other exported name, thanks to the nature of Julia macros.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A classic example of a task forever beyond the reach of regular expressions is balancing parentheses, with JLpeg this is easy:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"using JLpeg # hide\n@grammar parens begin\n    :par ← :s * !1\n    :s ← (:b | (!S\"()\" * 1))^1\n    :b ← '(' * :s * ')'\nend;\n\nmatch(parens, \"(these (must) balance)\")\n\nmatch(parens, \"these (must) balance)\")\n\nmatch(parens, \"(these (must) balance\")\n\nmatch(parens, \"(these (must) balance))\")\n\nmatch(parens, \"(these (must))) balance)\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"!1 is our equivalent of $ in regex, a pattern which only succeeds at the end of input.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The @grammar macro doesn't define variable names for the rules, only the grammar name given before the expression block.  The first rule, as always, is the start rule, as you can see, it needn't match the variable name.","category":"page"},{"location":"#Captures","page":"JLpeg Guide","title":"Captures","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A PegMatch defaults to the longest SubString when no captures are provided, or when the pattern succeeds but all captures within fail.  To capture only the substring of interest, use C(patt) or just make a tuple (patt,).  Don't forget the comma, or Julia will interpret this as a group.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> match(\"\" >> (P\"56\",), \"1234567\")\nPegMatch([\"56\"])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This matches the empty string, fast-forwards to the first 56, and captures it.  Note that the pattern is (P\"56\",), a tuple, not a group; this is syntax sugar for P(\"\") >> C(P(\"56\")).","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"[❓] Operation What it produces\n[✅] C(patt [, key]), captures the substring of patt\n[✅] (patt,) same as above, note the comma!\n[✅] (patt, key) key may be :symbol or \"string\"\n[✅] Cg(patt [, key]), captures a Vector of values produced by patt,\n[✅] [patt], ([patt], key) optionally tagged with key\n[✅] Cp() captures \"\" so PegMatch.offsets has the position\n[🔶] Cc(any) places any in .captures at the current offset\n[✅] Cr(patt [, key]) Range of indices [start:end] of patt, optional key\n[🔶️] Ce(patt, :key), groups the captures ofpatt and creates an Expr\n[🔶] patt => :key with head :key and args [patt]...","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Some more examples:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :cap123 ← [((S\"123\"^1,) | R\"az\"^1)^1];\n\njulia> match(cap123, \"abc123zyz123def\")\nPegMatch([[\"123\", \"123\"]])\n\njulia> @rule :cap_pos ← [((S\"123\"^1,) | R\"az\"^1 * Cp())^1];\n\njulia> match(cap_pos, \"abc123zyz123def\")\nPegMatch([[4, \"123\", 10, \"123\", 16]])\n\njulia> @rule :capABC ← [((S\"ABC\"^1,) | R\"az\"^1)^1, :capABC];\n\njulia> match(capABC, \"abcBCAzyzCCCdef\")\nPegMatch([:capABC => [\"BCA\", \"CCC\"]])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The form in :capABC, where the rule is grouped as a capture and given a symbol which is the same as the rule name, is extremely common and gets its own shorthand:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :capABC <--> ((S\"ABC\"^1,) | R\"az\"^1)^1;\n\njulia> match(capABC, \"abcBCAzyzCCCdef\")\nPegMatch([:capABC => [\"BCA\", \"CCC\"]])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"With both ⟷ and ↔︎ as synonyms.","category":"page"},{"location":"#Actions","page":"JLpeg Guide","title":"Actions","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A pattern may be modified with an action to be taken, either at runtime, or, more commonly, once the match has completed.  These actions are supplied with all captures in patt, or the substring matched by patt itself if patt contains no captures of its own.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"[❓] Action Consequence\n[✅] A(patt, λ), the returned value of λ, as applied\n[✅] patt <| λ to the captures in patt\n[⭕️] Anow(patt, λ), captures λ(C(patt)...) at match time,\n[⭕️] patt >: λ return nothing to fail the match\n[✅] T(:label), fail the match and throw :label\n[✅] patt % :label shorthand for patt | T(:label)\n[⭕️] M(patt, :label) mark a the region of patt for later reference\n[⭕️] K(patt, :label, op) checK patt against the last mark with op","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The use of <| is meant to be mnemonic of |> for ordinary piping (and shares its usefully low precedence), without pirating the meaning of the pipe operator.  This way patt |> λ will do the expected thing, λ(patt).","category":"page"},{"location":"#Throws-and-Recovery","page":"JLpeg Guide","title":"Throws and Recovery","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The ultimate challenge of good parsing has always been error reporting and recovery. With old-school lex and yacc, the conventional wisdom was to develop the grammar for a language or DSL using the compiler-compiler toolkit, to assure that the grammar is actually in a useful context-free class, then handroll a recursive-descent parser for production use, in order to provide users with useful error messages when they inevitably create syntax errors.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"JLpeg, being a PEG parser, is a formalization of the classic recursive-descent parsing strategy.  It includes a mechanism pioneered by lpeglabel, somewhat improved in the implementation, which allows a pattern to throw a specific error when an expected aspect of parsing is violated.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"T(:label) doesn't capture, but rather, fails the match, records the position of that failure, and throws :label.  If there is a rule by that name, it is attempted for error recovery, otherwise :label and the error position are attached to the PegFail struct, in the event that the whole pattern fails.  The label :default is reserved by JLpeg for reporting failure of patterns which didn't otherwise throw a label.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Consider a simplified pattern for matching double-quoted strings:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"using JLpeg #hide\n\n@rule :string  ←  \"'\" * (!\"'\" * 1)^0 * \"'\";\n\nmatch(string, \"'a string'\")\n\nmatch(string, \"'not a string\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"We do mark the point of failure, which is better than average; a normal PEG or parser combinator will silently fail to match, without informing the user of where. But we can do better with throws.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@rule :string  ←  \"'\" * (!\"'\" * 1)^0 * (\"'\" % :badstring)\n\nmatch(string, \"'not a string\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This provides us both with the point of failure, and the cause, data which can be used to provide a helpful error message to the user of your patterns, who may or may not be you.","category":"page"},{"location":"#Working-With-Matched-Data","page":"JLpeg Guide","title":"Working With Matched Data","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"PegMatch implements the interface of AbstractMatch, and as such, it is intentionally structured to be similar to RegexMatch from the standard library.  PEGs are a far richer and more sophisticated tool than regexen, however: a named capture might appear many times, captures can be grouped, those groups may have groups, with captures, having names, and so on.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Our intention is that simple matching will behave in a familiar way, with additional methods provided for more complex scenarios.  Let's consider a simple rule with some captures.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :baddate ← (R\"09\"^[4], :year) * \"-\" * (R\"09\"^[2:2],) * \"-\" * (R\"09\"^[2], :day);\n\njulia> date = match(baddate, \"2024-01-10\")\nPegMatch([:year => \"2024\", \"01\", :day => \"10\"])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The rule name is because this is certainly not how you should parse a date!","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Let's illustrate how to work with this.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> date == [:year => \"2024\", \"01\", :day => \"10\"]\ntrue\n\njulia> [:year => \"2024\", \"01\", :day => \"10\"] == date\ntrue","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A PegMatch is == to a Vector with the same contents.  However, note that a PegMatch uses default hash equality:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> hash(date) == hash([:year => \"2024\", \"01\", :day => \"10\"])\nfalse","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This is somewhat at variance with doctrine, but we feel it's the correct choice here.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Let's trying indexing our match:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> date[:day]\n\"10\"\n\njulia> date[3]\n\"10\"\n\njulia> keys(date)\n3-element Vector{Any}:\n  :year\n 2\n  :day\n\njulia> collect(pairs(date))\n3-element Vector{Pair{A, SubString{String}} where A}:\n :year => \"2024\"\n     2 => \"01\"\n  :day => \"10\"\n\njulia> collect(enumerate(date))\n3-element Vector{Pair{Int64, SubString{String}}}:\n 1 => \"2024\"\n 2 => \"01\"\n 3 => \"10\"","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"So far so good, what happens if a named capture matches more than once?","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :abcs ← ((R\"az\"^1, :abc) | \"123\")^1;\n\njulia> letters = match(abcs, \"abc123def123ghi123\")\nPegMatch([:abc => \"abc\", :abc => \"def\", :abc => \"ghi\"])\n\njulia> letters[:abc]\n\"abc\"\n\njulia> keys(letters)\n3-element Vector{Any}:\n  :abc\n 2\n 3\n\njulia> collect(pairs(letters))\n3-element Vector{Pair{Symbol, SubString{String}}}:\n :abc => \"abc\"\n :abc => \"def\"\n :abc => \"ghi\"","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"As you can see, the first match with that name is the indexable one, and therefore, is the only time :abc appears in keys, while all matches have their name in pairs, or, if anonymous, their index.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Complete docstring documentation of the JLPeg internal API.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JLpeg.Instruction\nJLpeg.VMState","category":"page"},{"location":"internals/#JLpeg.Instruction","page":"Internals","title":"JLpeg.Instruction","text":"Instruction\n\nAbstract type of JLPeg VM instructions.\n\nThe possible struct fields have consistent meanings:\n\nField Type Meaning\nop @enum UInt8 The Opcode\nl `Int32 16`\nn UInt32 A subject index\nc Char A character to match\nb UInt8 A test byte\ntag UInt32 Key in a capture/throw Dict\nvec BitVector (kinda) A set's test BitVector\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLpeg.VMState","page":"Internals","title":"JLpeg.VMState","text":"VMState(patt::Pattern, string::AbstractString)\n\nContains the state of a match on subject by program.\n\nFields\n\nOther than the subject and program, we have:\n\ntop: the byte length of subject\ni: Instruction counter\ns: Subject pointer\nti, ts, tc, tp: Stack top registers\nt_on: flag for nonempty stack\ninpred: Bool is true inside predicates (PAnd, PNot)\nsfar: furthest subject pointer we've failed at, for error reporting\nfailtag: tag for a labeled failure\nstack: Contains stack frames for calls and backtracks\ncap: A stack for captures\nrunning: Bool which is true when the VM is executing\nmatched: true if we matched the program on the subject\n\nImplementation\n\nClassic dispatch-driven VM with a program counter, opcodes, stack frames.  I borrowed a page from Forth and made the top of the stack a register, allowing stack frames to be immutable while still permitting the PartialCommit optimization.\n\n\n\n\n\n","category":"type"}]
}
