var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Core-API","page":"Reference","title":"Core API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The basic structure of recognition in JLPeg is a Pattern.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Pattern","category":"page"},{"location":"reference/#JLpeg.Pattern","page":"Reference","title":"JLpeg.Pattern","text":"Container for various patterns and grammars.  Always has val, which may be primitive or a Vector of patterns, and code, a Vector of Instructions. Some patterns have fields unique to that type of pattern.  A pattern which encloses other patterns will have an aux field containing a Dict for metadata.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Reference","title":"Reference","text":"These are created in a wide variety of ways, all based on three functions, P, S, and R, with the rest of the work done with a great quantity of operator overloading.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.PegMatch\nJLpeg.PegFail\nJLpeg.PegError","category":"page"},{"location":"reference/#JLpeg.PegMatch","page":"Reference","title":"JLpeg.PegMatch","text":"PegMatch <: AbstractMatch\n\nA type representing a successful match of a Pattern on a string.  Typically returned from the match function.  PegFail is the atypical return value.\n\nA PegMatch is equal (==) to a Vector if the captures are equal to the Vector.\n\nProperties:\n\nsubject::AbstractString:  Stores the string matched.\nfull::Bool:  Whether the match is of the entire string.\ncaptures::Vector:  Contains any captures from matching patt to subject.   This can in principle contain anything, as captures may call functions, in which   case the return value of that function becomes the capture.  For more   information, consult the JLPeg documentation, and the docstrings for C, Cg,   Cc, A, and Anow.\noffsets::Vector{Int}:  Provided for compatibility with AbstractMatch.  SubStrings contain their own offsets, so this is unnecessary for normal work,  but we generate them when match.offsets is used.  It then consists of the  indices at which the outer layer of captures may be found within the subject.\npatt::Pattern: The pattern matched against the subject.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.PegFail","page":"Reference","title":"JLpeg.PegFail","text":"PegFail\n\nReturned on a failure to match(patt:Pattern, subject::AbstractString).\n\nProperties\n\nsubject::AbstractString:  The string that we failed to match on.\nerrpos: The position at which the pattern ultimately failed to match.\nlabel::Symbol: Info about the failure provided by T(::symbol), defaulting to       :default if the pattern fails but not at a throw point, or if no throws are       provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.PegError","page":"Reference","title":"JLpeg.PegError","text":"PegError(msg) <: Exception\n\nAn error while constructing a Pattern.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Pattern-Matching","page":"Reference","title":"Pattern Matching","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"match\nJLpeg.compile!","category":"page"},{"location":"reference/#Base.match","page":"Reference","title":"Base.match","text":"match(patt::Pattern, subject::AbstractString)::Union{PegMatch, PegFail}\n\nMatch patt to subject, returning a PegMatch implementing the expected interface for its supertype AbstractMatch, or a PegFail with useful information about the failure.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.compile!","page":"Reference","title":"JLpeg.compile!","text":"compile!(patt::Pattern)::Pattern\n\nCompile a Pattern.\n\nTranslate the Pattern to Instruction codes, appending them to the code field and returning same.  Performs various optimizations in the process.\n\nIn most cases, the return value of compile! is the same Pattern passed in. The exceptions are special cases of primitive types, but be sure to reassign the return value to the variable bound to the original for the general case.\n\n\n\n\n\ncompile!(patt::PGrammar)::Pattern\n\nCompiles and prepares a Grammar.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Constructing-Patterns","page":"Reference","title":"Constructing Patterns","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Patterns are built by combining the products of these constructors into more complex Patterns.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.P\nJLpeg.@P_str\nJLpeg.S(s::AbstractString)\nJLpeg.@S_str\nR(::AbstractString)\nR(::AbstractChar, ::AbstractChar)\nJLpeg.@R_str\nJLpeg.B","category":"page"},{"location":"reference/#JLpeg.P","page":"Reference","title":"JLpeg.P","text":"P(p::Union{AbstractString,AbstractChar,Integer,Bool,Symbol})::Pattern\n\nCreate a Pattern.\n\nIf p is a String or Char, this matches that string or character.\nIf p is a positive Integer, it matches that many characters.\nIf p is true, the rules succeeds, if false, the rule fails.\nIf p is a Symbol, this represents a call to the rule with that name.\nIf p is a negative Integer, matches if that many characters remain, consumes no input.\nIf p is already a Pattern, it is simply returned.\n\nExamples\n\njulia> match(P(\"func\"), \"funci\")\nPegMatch([\"func\"])\n\njulia> match(P(3), \"three\")\nPegMatch([\"thr\"])\n\njulia> match(P(true), \"pass\")\nPegMatch([\"\"])\n\njulia> match(P(false), \"fail\")\nPegFail(\"fail\", 1)\n\njulia> match(P('üëç'), \"üëç\")\nPegMatch([\"üëç\"])\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.@P_str","page":"Reference","title":"JLpeg.@P_str","text":"P\"str\"\n\nCalls P(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.S-Tuple{AbstractString}","page":"Reference","title":"JLpeg.S","text":"S(s::AbstractString)\n\nCreate a Pattern matching any charcter in the string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.@S_str","page":"Reference","title":"JLpeg.@S_str","text":"S\"str\"\n\nCalls S(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.R-Tuple{AbstractString}","page":"Reference","title":"JLpeg.R","text":"R(s::AbstractString)\n\nCreate a Pattern matching every character in the range from the first to the second character.  s must be two codepoints long, and the first must be lower-valued than the second.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.R-Tuple{AbstractChar, AbstractChar}","page":"Reference","title":"JLpeg.R","text":"R(a::AbstractChar, b::AbstractChar)\n\nMatch any character in the range a to b, inclusive.\n\n\n\n\n\n","category":"method"},{"location":"reference/#JLpeg.@R_str","page":"Reference","title":"JLpeg.@R_str","text":"R\"str\"\n\nCalls R(str) on the String, in close imitation of Lua's calling convention.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.B","page":"Reference","title":"JLpeg.B","text":"B(p::Union{Pattern,AbstractString,AbstractChar,Integer})\n\nMatch patt behind the current subject index. patt must be of fixed length.  The most useful B patterns are !B(1), which succeeds at the beginning of the string, and B('\\n')|!B(1) to match the start of a line.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Combinators","page":"Reference","title":"JLpeg.Combinators","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Combinators","category":"page"},{"location":"reference/#JLpeg.Combinators","page":"Reference","title":"JLpeg.Combinators","text":"JLpeg.Combinators\n\nContains all the combinator operators which shadow definitions in Base.  The module redefines these symbols, providing a fallback to the Base, and are designed not to break existing code.  The Julia compiler handles this kind of redirection well during inference, this technique is used by several packages which specialize operators for numerically-demanding tasks, without issue; we even transfer the Base docstrings.\n\nWhether or not these overloads rise to the level of piracy is debatable.  That said, we've walled them off, so that debate is not necessary.\n\nUse\n\nThe @grammar and @rule macros are able to use these operators, so you may not need them.  To import them, add this to your module:\n\nimport JLpeg.Combinators: *, -, %, |, ^, ~, !, >>, >:, inv\n\n\n\n\n\n","category":"module"},{"location":"reference/#Captures-and-Actions","page":"Reference","title":"Captures and Actions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"PEG patterns are recognizers, matching the longest prefix of the string which they're able.  Captures allow for substrings to be captured within the match, Actions perform actions at the index of the match, or on a capture.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.C\nJLpeg.Cg\nJLpeg.Cr\nJLpeg.Cc\nJLpeg.Cp\nJLpeg.M\nJLpeg.CM\nJLpeg.K\nJLpeg.CK\nJLpeg.A\nJLpeg.Anow\nJLpeg.T","category":"page"},{"location":"reference/#JLpeg.C","page":"Reference","title":"JLpeg.C","text":"C(patt::Pattern)\n\nCreate a capture. Matching patt will return the matched substring.  The sugared form is (patt,).\n\n\n\n\n\nC(patt::Pattern, sym::Union{Symbol,AbstractString})\n\nCreate a named capture with key :sym or \"sym\".  Sugared form (patt, :sym).\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cg","page":"Reference","title":"JLpeg.Cg","text":"Cg(patt::Pattern [, sym::Union{Symbol,AbstractString}])\n\nCreate a group capture, which groups all captures from P into a vector inside the PegMatch object.  If sym is provided, the group will be found at that key.  Sugared as [patt] or [patt, :sym].\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cr","page":"Reference","title":"JLpeg.Cr","text":"Cr(patt::Pattern, sym::Union{CapSym, Nothing})\n\nCaptures a UnitRange of matches in patt, optionally keyed by sym. Convenient for substitutions and annotations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cc","page":"Reference","title":"JLpeg.Cc","text":"Cc(args...)\n\nConstant capture. Matches the empty string and puts the values of args as a tuple in that place within the PegMatch captures.  If args is a Pair{Symbol,Any}, that symbol will appear as a key in the match.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Cp","page":"Reference","title":"JLpeg.Cp","text":"Cp()\n\nCaptures the empty string in .captures, consuming no input.  Useful for the side effect, of storing the corresponding offset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.M","page":"Reference","title":"JLpeg.M","text":"M(patt::Pattern, sym::Symbol)\n\nMark the match of a pattern for later examination with K.\n\nSee also CM.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.CM","page":"Reference","title":"JLpeg.CM","text":"CM(patt::Pattern, sym::Symbol)\n\nMark the match of patt with sym, while also capturing it with sym.\n\nSee M and C for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.K","page":"Reference","title":"JLpeg.K","text":"K(patt::Pattern, sym::Symbol, [check::Union{Function,Symbol}])\n\nChecK the pattern against the previous Mark with the same tag. If check is not provided, it will return true if the SubStrings of the mark and check are identical, otherwise it must be either a symbol representing one of the builtins or a function with the signature (marked::SubString, checked::SubString)::Bool.  The success or failure of the check is the success or failure of the pattern.  If patt doesn't match, the check will not be performed. The check will always fail if the corresponding mark is not present, except for the builtin :true, which always succeeds if patt succeeds.\n\nSee also CK\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.CK","page":"Reference","title":"JLpeg.CK","text":"CK(patt::Pattern, sym::Symbol, check::Union{Function,Symbol})\n\nChecK the pattern against the prior [Mark], capturing if the check suceeds. See K and C for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.A","page":"Reference","title":"JLpeg.A","text":"A(patt::Pattern, Œª::Function)\n\nActs as a grouping capture for patt, applying Œª to a successful match with the captures as arguments (not as a single Vector). If patt contains no captures, the capture is the SubString.  The return value of Œª becomes the capture; if nothing is returned, the capture (and its offset) are deleted. May be invoked as patt <| Œª.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.Anow","page":"Reference","title":"JLpeg.Anow","text":"Anow(patt::Pattern, Œª::Function)\n\nActs as a grouping capture, applying Œª immediately upon a match succeeding to the captures inside patt, or the span of patt if there are no captures within it.  The return value of Œª becomes the capture, but if nothing is returned, the entire pattern fails.\n\n\n\n\n\n","category":"function"},{"location":"reference/#JLpeg.T","page":"Reference","title":"JLpeg.T","text":"T(label::Symbol)\n\nThrow a failure labeled with :label.  If a rule :label exists, this will be called to attempt recovery, the success or failure of the recovery rule is then used.  Otherwise, :label and the position of T(:label) will be attached to PegFail in the event that the whole match fails at that point in the string.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rules-and-Grammars","page":"Reference","title":"Rules and Grammars","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The great advantage (other than composability) PEGs have over regular expressions is the ability to match recursive patterns.  These are constructed out of Rules and Grammars.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.Grammar\nJLpeg.Rule\nJLpeg.@rule\nJLpeg.@grammar","category":"page"},{"location":"reference/#JLpeg.Grammar","page":"Reference","title":"JLpeg.Grammar","text":"Grammar(rule...)\n\nCreate a grammar from the provided rules.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.Rule","page":"Reference","title":"JLpeg.Rule","text":"Rule(name::Symbol, patt::Pattern)\n\nUn-sugared form of @rule, creates a rule from patt, assigning it the name name.\n\n\n\n\n\n","category":"type"},{"location":"reference/#JLpeg.@rule","page":"Reference","title":"JLpeg.@rule","text":"@rule :name ‚Üê pattern...\n\nSugared form for rule definition. Assigns the rule in-scope with the given name:\n\n# Wrong\nname = @rule :name  ‚Üê  \"foo\" | \"bar\"\n# Right\n@rule :name ‚Üê \"foo\" | \"bar\"\n\nIn terms of scope and variable escaping, @rule functions identically to @grammar.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#JLpeg.@grammar","page":"Reference","title":"JLpeg.@grammar","text":"@grammar(name, rules)\n\nSyntax sugar for defining a set of rules as a single grammar. Expects a block rules, each of which is a rule-pair as can be created with ‚Üê, or <--. \"string\" will be interpolated as P(\"string\"), :symbol as P(:symbol), and an integer n as P(n).\n\nAny variable name exported by JLpeg will refer to the same value as the export, while any other variable is escaped, and will have the meaning it has in the scope where @grammar is called.\n\nExample use\n\nThis simple grammar captures the first string of numbers it finds:\n\njulia> @grammar capnums begin\n            :nums  ‚Üê  (:num,) | 1 * :nums\n            :num   ‚Üê  R\"09\"^1\n        end;\n\njulia> match(capnums, \"abc123abc123\")\nPegMatch([\"123\"])\n\nThis one also captures the lowercase letters, converting them to uppercase.\n\njulia> upper = uppercase;  # A thoroughly unhygienic macro\n\njulia> @grammar uppernums begin\n           :nums  ‚Üê  (:num,) | :abc * :nums\n           :num   ‚Üê  R\"09\"^1\n           :abc   ‚Üê  R\"az\"^1 <| upper\n       end;\n\njulia> match(uppernums, \"abc123abc123\")\nPegMatch([\"ABC\", \"123\"])\n\nMore extensive examples may be found in the documentation.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Dialects","page":"Reference","title":"Dialects","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"A work in progress.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.re","category":"page"},{"location":"reference/#JLpeg.re","page":"Reference","title":"JLpeg.re","text":"re : An Interpretation of LPeg's `re` module\n\nThe first dialect, intended, among other things, as a useful bootstrap of other dialects.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Generators","page":"Reference","title":"Generators","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"A PEG is a specification of a class of algorithms which are valid on a universe of strings.  While the common thing to do is use this specification to construct a recognizer for such strings, it may also be used to create generators for valid strings in that universe.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg aspires to provide a complete set of generators for our patterns. So far, we have:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"JLpeg.generate","category":"page"},{"location":"reference/#JLpeg.generate","page":"Reference","title":"JLpeg.generate","text":"generate(set::PSet)::String\n\nGenerate a String of all characters matched by a Set.\n\n\n\n\n\n","category":"function"},{"location":"#JLpeg:-Pattern-Matching-and-Parsing-For-Julia","page":"JLpeg Guide","title":"JLpeg: Pattern Matching and Parsing For Julia","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"CurrentModule = JLpeg\nDocTestSetup = quote\n    using JLpeg\n    import JLpeg.Combinators: *, -, %, |, ^, ~, !, >>, >:, inv\nend","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"JLpeg provides a fast Parsing Expression Grammar engine for matching patterns in strings, using a bytecode virtual machine based on the pioneering work of Roberto Ierusalimschy.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared to regular expressions, PEGs offer greater power and expressivity.  They match a superset of regex patterns, while formalizing and extending the deviations from regular languages offered by production regex engines such as PCRE.  PEGs are able to parse recursive rule patterns, employ lookahead and lookbehind predicates, and avoid the sort of worst-case complexity the regex is prone to, for most useful patterns.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared with parser combinators, a more common algorithm for matching PEG grammars, the approach taken by this package is superior.  A bytecode interpreter allows several key optimizations which parser combinators do not in practice employ. Generally such libraries choose between a naive backtracking algorithm with bad time complexity, and a memorizing packrat algorithm which trades this for bad space complexity, with consequent memory pressure.  Critically, a JLpeg pattern of the form a ‚Üê \"b\" / . a becomes a loop, rather than consuming the program stack.  JLpeg generates programs which may be inspected and modified, and uses an innovative thrown-label pattern to allow excellent error reporting and recovery.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Compared with a \"compiler compiler\" such as ANTLR or the classic yacc/bison, JLpeg does not generate source code, but rather bytecode, which Julia is able to JIT into near-optimal machine code on the fly.  These systems require an imput stream to be reduced to tokens, an abstraction PEGs do not need, which allows JLpeg to parse contextually-valid grammars which cannot be readily tokenized.  PEGs are also far more suitable for scanning, captures, and other pattern-recognition tasks than these programs, which are only well-suited to parsing of full grammars, a task JLpeg also excels at.","category":"page"},{"location":"#Patterns","page":"JLpeg Guide","title":"Patterns","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Parsing Expression Grammars are built out of patterns. These begin with atomic units of recognition, and are combined into complex rules, which can call other rules, recursively, thereby recognizing context free, and some context sensitive, languages. LPeg, JLpeg's inspiration, uses a SNOBOL-style set of operator overloads as the basic tool for building up patterns, a practice we also follow.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Patterns and their combination are the building block of JLpeg recognition engines. They are immutable and may be freely recombined and reused, unlike either regular expressions or the parsers generated by typical compiler-compilers.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The API of JLpeg hews closely to LPeg, with several extensions, refinements, and a more natively Julian character.","category":"page"},{"location":"#Combination","page":"JLpeg Guide","title":"Combination","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The basic operations are as follows:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Operator Description\nP(string::String) match a literal String string\nP(n::UInt) match any n characters\nP(-n) match if there are at least n characters remaining\nP(sym::Symbol) match the rule named :sym\nS(s::String) match the Set of all characters in string\nR(\"xy\"), R('x','y') matches any character between x and y (Range)\nB(patt) match patt behind the cursor, without advancing\npatt^n match at least n repetitions of patt\npatt^-n match at most n repetitions of patt\npatt^[n:m] match between n and m repetitions of patt\npatt^[n] match exactly n repetitions of patt\npatt1 * patt2 match the sequence patt1 , patt2\npatt1 | patt2 match patt1 or patt2, in that order\npatt1 - patt2 match patt1 if patt2 does not match\n!patt, ¬¨patt negative lookahead, succeeds if patt fails\n~patt lookahead, match patt without advancing\npatt1 >> patt2 match patt1, then search the string for the next patt2.\nP(true), Œµ always succeed\nP(false), ‚àÖ always fail","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"In keeping with the spirit of LPeg, P\"string\" is equivalent to P(\"string\"), and this is true for S and R as well.  These basic operations are not recursive, and without further modification will match to the longest substring recognized by the pattern.  This is sufficient to match all regular languages.","category":"page"},{"location":"#A-Note-About-Piracy","page":"JLpeg Guide","title":"A Note About Piracy","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"You will note that combining Patterns involves a great deal of operator overloading. In Julian circles, operators are presumed to have a certain contract, although this is informal and has a certain latitude.  Some of our operators comply with this expectation: * and ^ are used for concatenation and repetition for AbstractStrings, as they are with Patterns, although the meaning of repetition is broader for patterns.  Others do not: particularly egregious is !, which is expected to always return a Bool, and >: (an Action), which has no relationship to supertypes whatsoever.  | and - are justifiable, in my opinion: | is firmly grounded in tradition and a | b would be pronounced \"a or b\", while subtraction has a huge variety of meanings in mathematics; our use, as one should expect, is neither commutative nor associative. ~ and >> bear little resemblance to their ordinary meanings.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Broadly speaking, the combinator operators in JLpeg are a combination of availability, operator precedence, and mnemnonic weight, in that order.  For example, &patt is the signifier for lookahead in the PEG definition, we use ~ because it's unary, and Julia has but few unary operators.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"In any case, we shadow operators, rather than overloading the ones found in Base, and they aren't exported.  We provide JLpeg.Combinators as an easy way to bring them into scope if desired.  Most users will stick to the @rule and @grammar macros, which don't require bringing operators into scope.","category":"page"},{"location":"#Matching","page":"JLpeg Guide","title":"Matching","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"match(pattern::Pattern, string::AbstractString) will attempt to match the pattern against the string, returning a PegMatch <: AbstractMatch. In the event of a failure, it returns a PegFail, with the index of the failure at .errpos.  Note that unlike regular expressions, JLpeg will not skip ahead to find a pattern in a string, unless the pattern is so constructed.  We offer the easy shorthand \"\" >> patt to convert a pattern into its searching equivalent; P\"\" matches the empty string, and JLPeg will convert strings and numbers (but not booleans) into patterns when able.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> match(P\"123\", \"123456\")\nPegMatch([\"123\"])\n\njulia> match(P\"abc\" * \"123\", \"abc123\")\nPegMatch([\"abc123\"])\n\njulia> match(P\"abc\" | \"123\", \"123\")\nPegMatch([\"123\"])\n\njulia> match(P\"abc\"^1, \"abcabcabc\")\nPegMatch([\"abcabcabc\"])\n\njulia> match((!S\"123\" * R\"09\")^1, \"0987654321\")\nPegMatch([\"0987654\"])\n\njulia> match(\"\" >> P\"5\", \"0987654321\")\nPegMatch([\"098765\"])\n\njulia> match(~P\"abc\", \"abc123\")\nPegMatch([\"\"])\n\njulia> match(~P\"abc\", \"123abc\") # fails\nPegFail(\"123abc\", 1)","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The operators introduce a pattern 'context', where any a <op> b combination where a or b is a Pattern will attempt to cast the other argument to a Pattern when appropriate.  Generally, a MethodError may be repaired by using P on the left side of the the operator, although we can't guarantee that other method overloads for those operators might apply.  Notably, * is used for concatenation of strings, although in the JLpeg context, P\"abc\" * P\"123\" is in fact the same as P(\"abc\" * \"123\").","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This UI is adequate for light work, but the macros discussed later are cleaner to work with, defined such that P should never be necessary, although any of the public names in the JLpeg module may be used, and needn't be imported into your package to do so.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Note that, unlike regular expressions, PEG matching always starts with the first character.  Any match returned by a call to match(patt, string) will therefore be a prefix of the string, up to and including the entire string.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Most interesting uses of pattern recognition will call for more than matching the longest substring.  For those more complex cases, we have Captures and Actions.","category":"page"},{"location":"#Rules-and-Grammars","page":"JLpeg Guide","title":"Rules and Grammars","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"While simple patterns may be composed by assigning to variables and using those variable names to build up more complex patterns, this doesn't allow for recursion, which is essential for matching many strings of interest, perhaps most.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"For this purpose, we have rules, which are simply named patterns.  A rule with no references to another rule within it may be used for matching directly, while those with such references (including a reference to itself) must be composed into grammars.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"As is the PEG convention, a rule reduction uses the left arrow ‚Üê, which you can type as \\leftarrow (or in fact \\lefta[TAB]), also defined as <--.  A simple grammar can look like this:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"abc_and = :a <-- P\"abc\" * (:b | P\"\")\n_123s   = :b ‚Üê P\"123\"^1 * :a\nabc123  = Grammar(abc_and, _123s)\n\nmatch(abc123, \"abc123123123abc123abc\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Although we suggest as a matter of style that a grammar use one arrow form or the other, with ‚Üê preferred.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The first rule is the start rule, which must succeed if the match is to succeed.  A grammar which is missing rules will throw a PegError, but duplicate rules are undefined behavior.  Currently JLpeg will compile the last rule of that name it encounters, but this behavior must not be relied upon.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The preferred way to create rules and grammars is with the macros @rule and @grammar, which avoid the tedium of decorating expressions with P entirely.  Any Integer, String, Symbol, or Char, found on its own, is converted into the pattern equivalent.  While this is not true of booleans, the idiomatic way to spell true and false in JLpeg is \"\" and S\"\" respectively, and these are compiled into the same code as P(true) and P(false).  JLpeg also defines, but does not export, Œµ for P(true) and ‚àÖ for P(false), and these may be used in grammars and rules as well, with \\varepsilon (\\vare[TAB]) and \\emptyset (\\emp[TAB]) respectively.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Exported variable names from JLpeg will always refer to the values they have in the module.  Any other variable will be escaped, so it will have the expected meaning.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"To give an example, this rule:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@rule :a ‚Üê \"foo\" *  [S\"123\" | \"abc\"^0]^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Is equivalent to this expression:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"a = :a ‚Üê P(\"foo\") * Cg(S(\"123\") | P(\"abc\")^0)^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Although the definitions of the operators and string macros would allow this reduction:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"a = :a ‚Üê P\"foo\" * Cg(S\"123\" | \"abc\"^0)^1","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Which is a bit less cumbersome (we try).  Note that the @rule form doesn't require the importation of @S_str, or any other exported name, thanks to the nature of Julia macros.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A classic example of a task forever beyond the reach of regular expressions is balancing parentheses, with JLpeg this is easy:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"using JLpeg # hide\n@grammar parens begin\n    :par ‚Üê :s * !1\n    :s ‚Üê (:b | (!S\"()\" * 1))^1\n    :b ‚Üê '(' * :s * ')'\nend;\n\nmatch(parens, \"(these (must) balance)\")\n\nmatch(parens, \"these (must) balance)\")\n\nmatch(parens, \"(these (must) balance\")\n\nmatch(parens, \"(these (must) balance))\")\n\nmatch(parens, \"(these (must))) balance)\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"!1 is our equivalent of $ in regex, a pattern which only succeeds at the end of input.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The @grammar macro doesn't define variable names for the rules, only the grammar name given before the expression block.  The first rule, as always, is the start rule, as you can see, it needn't match the variable name.","category":"page"},{"location":"#Captures","page":"JLpeg Guide","title":"Captures","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A PegMatch defaults to the longest SubString when no captures are provided, or when the pattern succeeds but all captures within fail.  To capture only the substring of interest, use C(patt) or just make a tuple (patt,).  Don't forget the comma, or Julia will interpret this as a group.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> match(\"\" >> (P\"56\",), \"1234567\")\nPegMatch([\"56\"])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This matches the empty string, fast-forwards to the first 56, and captures it.  Note that the pattern is (P\"56\",), a tuple, not a group; this is syntax sugar for P(\"\") >> C(P(\"56\")).","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"[‚ùì] Operation What it produces\n[‚úÖ] C(patt [, key]), captures the substring of patt\n[‚úÖ] (patt,) same as above, note the comma!\n[‚úÖ] (patt, key) key may be :symbol or \"string\"\n[‚úÖ] Cg(patt [, key]), captures a Vector of values produced by patt,\n[‚úÖ] [patt], ([patt], key) optionally tagged with key\n[‚úÖ] Cp() captures \"\" so PegMatch.offsets has the position\n[üî∂] Cc(any) places any in .captures at the current offset\n[‚úÖ] Cr(patt [, key]) Range of indices [start:end] of patt, optional key","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Some more examples:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :cap123 ‚Üê [((S\"123\"^1,) | R\"az\"^1)^1];\n\njulia> match(cap123, \"abc123zyz123def\")\nPegMatch([[\"123\", \"123\"]])\n\njulia> @rule :cap_pos ‚Üê [((S\"123\"^1,) | R\"az\"^1 * Cp())^1];\n\njulia> match(cap_pos, \"abc123zyz123def\")\nPegMatch([[4, \"123\", 10, \"123\", 16]])\n\njulia> @rule :capABC ‚Üê [((S\"ABC\"^1,) | R\"az\"^1)^1, :capABC];\n\njulia> match(capABC, \"abcBCAzyzCCCdef\")\nPegMatch([:capABC => [\"BCA\", \"CCC\"]])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The form in :capABC, where the rule is grouped as a capture and given a symbol which is the same as the rule name, is extremely common and gets its own shorthand:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :capABC <--> ((S\"ABC\"^1,) | R\"az\"^1)^1;\n\njulia> match(capABC, \"abcBCAzyzCCCdef\")\nPegMatch([:capABC => [\"BCA\", \"CCC\"]])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"With both ‚ü∑ and ‚ÜîÔ∏é as synonyms, these are \\longleftrightarrow and \\:left_right_arrow respectively.","category":"page"},{"location":"#Actions","page":"JLpeg Guide","title":"Actions","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A pattern may be modified with an action to be taken, either at runtime, or, more commonly, once the match has completed.  These actions are supplied with all captures in patt, or the substring matched by patt itself if patt contains no captures of its own.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"[‚ùì] Action Consequence\n[‚úÖ] A(patt, Œª), the returned value of Œª, as applied\n[‚úÖ] patt <| Œª to the captures in patt\n[‚≠ïÔ∏è] Anow(patt, Œª), captures Œª(C(patt)...) at match time,\n[‚≠ïÔ∏è] patt >: Œª return nothing to fail the match\n[‚úÖ] M(patt, :label) Mark a the region of patt for later reference\n[‚úÖÔ∏è] K(patt, :label, op) checK patt against the last mark with op\n[‚úÖ] T(:label), fail the match and throw :label\n[‚úÖ] patt % :label shorthand for patt | T(:label)","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The use of <| is meant to be mnemonic of |> for ordinary piping (and shares its usefully low precedence), without pirating the meaning of the pipe operator.  This way patt |> Œª will do the expected thing, Œª(patt).","category":"page"},{"location":"#Marks-and-Checks","page":"JLpeg Guide","title":"Marks and Checks","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Validation and parsing of strings frequently requires comparison between two substrings.  For our example, let's consider this toy XML tag grammar.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"using JLpeg","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@grammar xmltag begin\n    :doc ‚Üê :tags * !1\n    :tags ‚Üê :opentag * :tags^0 * :closetag\n    :opentag ‚Üê \"<\" * R\"az\"^1 * \">\"\n    :closetag ‚Üê \"</\" * R\"az\"^1 * \">\"\nend;\n\nmatch(xmltag, \"<a><b></b></a>\")\n\nmatch(xmltag, \"<a><b></b>\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"So far so good! We've got a nice recursive tag matcher, without summoning Zalgo.  One problem though: it allows any close tag to match any open tag.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"match(xmltag, \"<a><b></a></b>\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"To solve this, we have the mark and check mechanism. Let's rewrite the grammar to use them.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@grammar xmltag begin\n    :doc ‚Üê :tags * !1\n    :tags ‚Üê :opentag * :tags^0 * :closetag\n    :opentag ‚Üê \"<\" * M(R\"az\"^1, :tag) * \">\"\n    :closetag ‚Üê \"</\" * K(R\"az\"^1, :tag) * \">\"\nend;\n\nmatch(xmltag, \"<a><b></a></b>\")\n\nmatch(xmltag, \"<a><b></b></a>\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"More like it! This mechanism allows for a fully declarative PEG grammar which matches valid XML.  It's also applicable to Python-style indentation, Lua's long strings, and much more.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"K has a two-argument form (shown), where the check confirms that the two substrings are identical.  In the three-argument form, a function may be provided, which must have the signature (marked::AbstractString, checked::AbstractString)::Bool, with the result of calling the function on the regions of interest used to pass or fail the match.  JLpeg provides several built-ins, which may be invoked by providing these symbols as the third argument:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"#TODO the built-ins","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"With the exception of the built-in :true check, a check will always fail if the pattern hasn't captured a mark with the same key.  This includes user-provided functions, which won't trigger if a mark isn't found.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Marks and checks are independent of the capture mechanism, but since the regions of interest are frequently worth capturing, we provide CM(patt) as a shorthand for C(M(patt)), and CK(patt) as shorthand for C(K(patt)).","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Marks and checks come with an important limitation: they must not contain other marks and checks.  Any other pattern is ok, including captures and all other actions. A future version of JLpeg may check for this condition and refuse to compile, the current behavior will silently corrupt your parse.  The author's opinion is that this is no limitation in practice, after all, one might match the longer region and perform whatever inner checks are desired.  If you find yourself with a real-world grammar which would benefit from nested marks, feel free to open an issue, and we can decide if the complexity, performance impact, and unclear semantics (does an inner mark come before, or after, its enclosing mark?) is worth it.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Note that marks are only removed once a corresponding check succeeds, and grammars or strings which don't close their marks will leave them on the stack.  This is normally harmless, the worst that can come of it is JLpeg throwing an InexactError once there are more than typemax(UInt16) marks on the stack, but it's certainly possible to create bad performance.  For example, by stacking up a bunch of mark :a while checking for mark :b, every check will be forced to fruitlessly look for the nonexistent mark on a growing stack of marks.  It takes some real effort to produce a grammar which will do this, however.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"If you have a grammar where some paired regions may be implicitly closed, you can use K(patt, :tag, :true) to automatically close the mark; this check succeeds whether the mark exists or not.  If you want the check to fail if the mark doesn't exist, use K(patt, :tag, :close) instead.  This comes up in Markdown parsing, where, for example, ** for emphasis is allowed to end when the paragraph ends, without needing to be closed.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Final note: this thorough discussion might leave some with the impression that marks and checks aren't performant, are tricky, to be avoided in practice, etc.  Fear not! Typical uses will consume marks nearly as fast as they're generated, and it's rare for marks to overlap, that is, normally the check will be compared against the latest mark.  To cite our XML example, the mark stack will be as deep as the tags are nested, comparisons are always against the top mark, and any mismatch fails the entire parse. This has the same time complexity as a grammar which allows mismatched tags, with a tiny added constant factor which is well-used.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Practical use of mark and check is as fast as it reasonably can be, and enables recognition of many common patterns in strings.","category":"page"},{"location":"#Throws-and-Recovery","page":"JLpeg Guide","title":"Throws and Recovery","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The greatest challenge for good parsing has always been error reporting and recovery. With old-school lex and yacc, the conventional wisdom was to develop the grammar for a language or DSL using the compiler-compiler toolkit, to assure that the grammar is actually in a useful context-free class, then handroll a recursive-descent parser for production use, in order to provide users with useful error messages when they inevitably create syntax errors.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"JLpeg, being a PEG parser, is a formalization of the classic recursive-descent parsing strategy.  It includes a mechanism pioneered by lpeglabel, modestly improved in our implementation, which allows a pattern to throw a specific error when an expected aspect of parsing is violated.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"T(:label) fails the match, records the position of that failure, and throws :label.  If there is a rule by that name, it is attempted for error recovery, otherwise :label and the error position are attached to the PegFail struct, in the event that the whole pattern fails.  The label :default is reserved by JLpeg for reporting failure of patterns which didn't otherwise throw a label.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Consider a simplified pattern for matching single-quoted strings:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"using JLpeg #hide","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@rule :string ‚Üê \"'\" * (!\"'\" * 1)^0 * \"'\";\n\nmatch(string, \"'a string'\")\n\nmatch(string, \"'not a string\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"We do mark the point of failure, which is better than average; a normal PEG or parser combinator will silently fail to match, without informing the user of where. But we can do better with throws.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"@rule :string  ‚Üê  \"'\" * (!\"'\" * 1)^0 * (\"'\" % :badstring)\n\nmatch(string, \"'not a string\")","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This provides us both with the point of failure, and the cause, data which can be used to provide a helpful error message to the user.","category":"page"},{"location":"#Working-With-Matched-Data","page":"JLpeg Guide","title":"Working With Matched Data","text":"","category":"section"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"PegMatch implements the interface of AbstractMatch, and as such, it is intentionally structured to be similar to RegexMatch from the standard library.  PEGs are a far richer and more sophisticated tool than regexen, however: a named capture might appear many times, captures can be grouped, those groups may have groups, with captures, having names, and so on.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Our intention is that simple matching will behave in a familiar way, with additional methods provided for more complex scenarios.  Let's consider a simple rule with some captures.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :baddate ‚Üê (R\"09\"^[4], :year) * \"-\" * (R\"09\"^[2:2],) * \"-\" * (R\"09\"^[2], :day);\n\njulia> date = match(baddate, \"2024-01-10\")\nPegMatch([:year => \"2024\", \"01\", :day => \"10\"])","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"The rule name is because this is certainly not how you should parse a date!  Note the two equivalent ways of specifying a definite number of repetitions, [2] is preferred.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Let's illustrate how to work with this.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> date == [:year => \"2024\", \"01\", :day => \"10\"]\ntrue\n\njulia> [:year => \"2024\", \"01\", :day => \"10\"] == date\ntrue","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"A PegMatch is == to a Vector with the same contents.  However, note that a PegMatch uses default hash equality:","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> hash(date) == hash([:year => \"2024\", \"01\", :day => \"10\"])\nfalse","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"This is somewhat at variance with doctrine, but we feel it's the correct choice here.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Next, let's look at iteration and indexing.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> date[:day]\n\"10\"\n\njulia> date[3]\n\"10\"\n\njulia> keys(date)\n3-element Vector{Any}:\n  :year\n 2\n  :day\n\njulia> collect(date)\n3-element Vector{Any}:\n \"2024\"\n \"01\"\n \"10\"\n\njulia> collect(eachindex(date))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> collect(pairs(date))\n3-element Vector{Pair{A, SubString{String}} where A}:\n :year => \"2024\"\n     2 => \"01\"\n  :day => \"10\"\n\njulia> collect(enumerate(date))\n3-element Vector{Pair{Int64, SubString{String}}}:\n 1 => \"2024\"\n 2 => \"01\"\n 3 => \"10\"","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"Default iteration will get you the matches, pairs uses the name of the capture when there is one, if a capture has a name, that can be used to index it, or the position in the Vector.","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"So far so good, what happens if a named capture matches more than once?","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"julia> @rule :abcs ‚Üê ((R\"az\"^1, :abc) | \"123\")^1;\n\njulia> letters = match(abcs, \"abc123def123ghi123\")\nPegMatch([:abc => \"abc\", :abc => \"def\", :abc => \"ghi\"])\n\njulia> letters[:abc]\n\"abc\"\n\njulia> keys(letters)\n3-element Vector{Any}:\n  :abc\n 2\n 3\n\njulia> collect(pairs(letters))\n3-element Vector{Pair{Symbol, SubString{String}}}:\n :abc => \"abc\"\n :abc => \"def\"\n :abc => \"ghi\"","category":"page"},{"location":"","page":"JLpeg Guide","title":"JLpeg Guide","text":"As you can see, the first match with that name is the indexable one, and therefore, is the only time :abc appears in keys, while all matches have their name in pairs, or, if anonymous, their index.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Complete docstring documentation of the JLPeg internal API.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JLpeg.Instruction\nJLpeg.VMState","category":"page"},{"location":"internals/#JLpeg.Instruction","page":"Internals","title":"JLpeg.Instruction","text":"Instruction\n\nAbstract type of JLPeg VM instructions.\n\nThe possible struct fields have consistent meanings:\n\nField Type Meaning\nop @enum UInt8 The Opcode\nl `Int32 16`\nn UInt32 A subject index or offset\nc Char A character to match\nb UInt8 A test byte\ntag UInt16 Key in a capture/throw Dict\ncheck UInt16 Which check to perform\nvec BitVector (kinda) A set's test BitVector\n\n\n\n\n\n","category":"type"},{"location":"internals/#JLpeg.VMState","page":"Internals","title":"JLpeg.VMState","text":"VMState(patt::Pattern, subject::AbstractString)\n\nContains the state of a match on subject by program.\n\nFields\n\nOther than the subject, program, and patt, we have:\n\ntop: the byte length of subject\ni: Instruction counter\ns: Subject pointer\nti, ts, tc, tm, tp: Stack top registers\nt_on: flag for nonempty stack\nrunning: Bool which is true when the VM is executing\nmatched: true if we matched the program on the subject\ninpred: Bool is true inside predicates (PAnd, PNot)\nsfar: furthest subject pointer we've failed at, for error reporting\nfailtag: tag for a labeled failure\nstack: Contains stack frames for calls and backtracks\ncap: A stack for captures\nmark: A stack for marks\n\nImplementation\n\nClassic dispatch-driven VM with a program counter, opcodes, stack frames.  I borrowed a page from Forth and made the top of the stack a register, allowing stack frames to be immutable while still permitting the PartialCommit optimization.\n\n\n\n\n\n","category":"type"}]
}
